面试问题

# 网络

## cookie 和 session 

### cookie

cookie的访问方式有两种，

- 通过js访问，document.cookie返回当前页面的可用cookie，但是这种情况下很容易被黑客窃取cookie信息，可以通过生成cookie时设置 HttpOnly 属性为true，限制cookie只能在http发送请求时携带
- 设置cookie时会设置domain域名，当用户向这个域名发送请求时，浏览器会自动去自己存储的cookie列表中（这个列表包含所有cookie，包含httponly的，而且同一域名下可能会有多个cookie），查找到当前域名下的所有cookie，然后加到 http请求中发送给服务器（如果是fetch请求的话需要设置 withCredentials:true 浏览器才会在http请求中加cookie），服务器收到后查找最匹配的cookie并进行响应操作（？？？？是客户端把所有cookie都发送给服务器吗）
  - 一般cookie是由服务端生成的，服务端通过在发送给客户端的响应报文头中设置 set-cookie 字段来设置cookie
  - 客户端自己可以通过设置 document.cookie 来**添加**一个新的cookie（不会覆盖已有cookie，除非设置cookie 的 name、value、domain、path 都和一个已存在的cookie重复）

session

https://harttle.land/2015/08/10/cookie-session.html

cookie和session都不是绝对安全的，只是session可以更有效地防止恶意用户对重要信息进行篡改之后，再对服务器发送篡改信息之后的攻击（但是它们对于预防重放攻击的处理办法都是相通的），因为cookie是明文，而session是服务器生成的哈希串，而且还带了checksum校验

防止重放攻击：对cookie内容进行加密，加入时间戳格式（或服务器和客户端商定的随机数递增模式），对内容进行加密之后再传输（保证每次加密的密文都不一样）

sessionStorage

cookieStorage

https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API

## HTTP

### 为什么 HTTPS 网站不能发送 HTTP 请求

混合内容：在HTTPS网站中使用HTTP发送了请求（script 或者 img src 或者 请求），http请求没有安全保障，可能会被中间代理人或其他恶意网站劫持而对用户的网站造成伤害

- 通过简单的script引入不安全的http请求：攻击者可以将代码注入返回的内容，并控制整个页面
- 通过请求（XMLHttpRequest 或 fetch）获取的数据用于更新innerHTML

### HTTP 和 HTTPS 的区别，主要用了什么加密算法

1. HTTPS协议需要CA证书

2. HTTP协议运行在TCP上，所有传输的内容都是明文

   HTTPS协议运行在SSL/TLS上，SSL运行在TCP上，所有传输内容经过加密

3. 端口不同：HTTP：80、HTTPS：443

HTTPS网站 **非对称加密**的过程

https://segmentfault.com/a/1190000005597589

1. 服务器使用RSA（非对称密钥生成技术）生成两个不同的秘钥k1和 k2， 使用k1加密的消息只能用 k2 解开，而是用k2 加密的消息 只能用 k1 解开，生成之后，服务器将k1 作为公钥发送给客户端
2. 客户端接收到这个公钥，并自己生成一个新的秘钥 key，使用服务端发送的公钥 k1 加密这个密钥 key 之后，发送给服务端
3. 服务端接收到加密的 密钥 key， 使用自己的私钥 k2 将其解密，获得客户端-服务器通信的真正对称密钥 key
4. 之后的数据传输使用 key 进行加密和解密

其实HTTPS网站非对称加密，只是使用非对称的加密方式来传输真正的对称密钥，因为非对称的加密解密过程十分耗时，而对称加密则能减少加密解密的时间

而单纯的对称加密又会在传输密钥的过程中有密钥泄露的危险，

所以使用 非对称是比较安全的做法

问题：

就算使用了非对称加密，HTTPS网站还是无法避免**中间人攻击**，中间人可以在客户端和服务器发送 非对称密钥的时候，就劫持服务端 的k1 密钥，并假装自己是客户端，使用k1 生成自己的秘钥 key2，并将其发送给服务器，并把这个密钥也发送给客户端，让客户端和服务器都认为自己与对方完成了密钥交换，那么整个传输过程就变成了 服务器 （加密）-> 中间人（明文） -> 客户端（加密），中间人可以获取双方发送的请求的具体内容是什么

HTTPS避免中间人攻击的方式：**CA证书**，客户端发送请求时服务端返回证书和公开密钥（公开密钥作为证书的一部分），只有通过客户端验证的证书，客户端才会使用这个公开密钥（这个公开密钥就是服务端生成的 两个非对称密钥中的一个，需要提前向CA认证机构申请，并确认这个公开密钥的合法性，之后这个公开密钥直接由CA证书传递）来生成对称加密的 key，并发送给服务器

https://www.cnblogs.com/handsomeBoys/p/6556336.html

各个网站服务商可以向 CA 申请证书，使得他们在建立安全连接时可以带上 CA 的签名。而 CA 得安全性是由操作系统或者浏览器来认证的。

你的 Windows、Mac、Linux、Chrome、Safari 等会在安装的时候带上一个他们认为安全的 CA 证书列表，只有和你建立安全连接的网站带有这些CA的签名，操作系统和浏览器才会认为这个链接是安全的，否则就有可能遭到中间人攻击。

一旦某个 CA 颁发的证书被用于的非法途径，那么这个 CA 之前颁发过的所有证书都将被视为不安全的，这让所有 CA 在颁发证书时都十分小心，所以 CA 证书在通常情况下是值得信任的。

### HTTP1.0、HTTP1.1、HTTP2.0

#### HTTP1.0和HTTP1.1的区别

1. **缓存处理**：
   - HTTP1.0：if-Modified-since，Expires
   - HTTP1.1：ETag、If-None-Match、Last-Modified、If-Unmidified-Since

2. **带宽优化及网络连接**
   - HTTP1.0：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
   - HTTP1.1：请求头引入 range域，允许之请求资源的某个部分（返回206）
3. **错误通知**（状态码）HTTP1.1新增
   - 409：conflict 请求资源与资源的当前状态发生冲突
   - 410：Gone 服务器上某个资源被永久性删除
4. **Host头处理**
   - HTTP1.0：认为每台服务器绑定一个唯一的IP地址
   - HTTP1.1：服务器中产生 虚拟主机，一个物理服务器上可以有多个虚拟主机，并且它们共享一个IP地址。所以HTTP1.1 的请求消息中必须用Host头域来指定 请求的主机名
5. **长连接**
   - HTTP1.0：默认关闭长连接，只有设置`Connection: keey-alive` 才能开启长连接
   - HTTP1.1：默认开启长连接，只有设置`Connection: close` 才能关闭连接
   - 长连接的好处：
     - 在一个TCP连接上可以传送多个HTTP请求和响应
     - 减少建立和关闭TCP的时延
     - 减少慢启动时延

#### HTTP2.0 和 HTTP1.x相比的新特性

- **二进制格式**。

  - HTTP1.x解析基于文本，需要考虑更多健壮性场景
  - 2.0只使用二进制

- **多路复用**：连接共享

  一个连接上可以有多个request，每个request可以随机混杂在一起，接收方可以根据request的id 将request再归属到各自不同的服务端请求里

- **header压缩**：使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields 表

- **服务端推送**：可以把客户端需要的资源伴随 index.html 一起发送到客户端，省去了客户端重复请求的步骤

#### HTTP2.0 多路复用 和 HTTP1.x中的长连接复用的区别

- HTTP1.0：一次请求-响应，建立一个连接，用完关闭（每个请求都要建立一个连接）
- HTTP1.1：若干个请求**串行化单线程**处理，后面的请求等待前面请求返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞——线头阻塞
- HTTP2.0：多个请求可以同时在一个连接上**并行**执行，一个请求耗时严重不会影响其他连接的正常执行

![1552811110029](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552811110029.png)

### 缓存 cache-control



### HTTP事务的时延

1. DNS解析：如果最近没有访问过这个URL（即缓存中没有这个URL）
2. TCP事务时延导致HTTP事务时延

### CA证书是什么，如何判定合法

由CA认证机构签发的一种身份认证

## TCP

### TCP事务的时延

1. TCP连接握手时延

2. TCP延时确认机制造成的时延：

   延时确认：每个TCP报文段到达接收方的时候，接收方都会回送一个ack报文给发送方。而延时确认就是搞一个缓冲区，把ack报文放进去，当接收方这边有需要发送给发送方的数据的时候，把ack报文放进去 “捎带”给发送方，如果一直没有数据需要发送，那么会设置一个超时时间，超过这个时间就会单独把ack报文发回去

   HTTP具有双峰特征的请求 - 应答行为降低了捎带信息的可能，当希望有相反方向回传分组的时候，偏偏没有那么多。所以延迟确认算法会引入很大的时延

   为什么延时确认会引入时延？TCP滑动窗口

   ![1552807107448](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807107448.png)

   ![1552807131709](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807131709.png)

3. TCP慢启动

   TCP连接刚刚建立的时候会有这种策略

   限制一个TCP端点在任意时刻可以传输的分组数，每成功接收一个分组，发送端就有了发送另外两个分组的权限（这个时候是需要确认上一个tcp之后才能发送下一个）+——打开拥塞窗口（调谐）

   但是这个传输分组的数量是有上限的，到达上限之后就不需要重新确认了

4. Nagle算法

   - 充分利用带宽，鼓励每次tcp报文都发送全尺寸的段
   - 将小尺寸的分组数据放在缓存区
   - 只有接收到上一次tcp请求的ack，才能将缓存区中的内容发出去
   - 和 延时确认算法一起使用时，会造成每个tcp请求都被延时

### TCP请求建立 三次握手，是否每次请求都需要三次握手

TCP三次握手：SYN-SEND——SYN-RCVD——ESTABLISHED

TCP四次挥手：FIN_WAIT_1——CLOSE_WAIT——LAST_ACK————TIME_WAIT（如果最后一个确认包没有发送成功，需要重发）——CLOSED

https://hit-alibaba.github.io/interview/basic/network/TCP.html

HTTP1.0协议是每次请求都要建立一个新的TCP连接，但是可以通过设置 keep-alive 让客户端和服务器来保持连接，这样下次发送请求时就不需要重新建立TCP连接了（HTTP1.1 默认为持久连接，HTTP2.0 多路复用）

## 性能优化

### 从一个url页面到页面显示步骤

https://mp.weixin.qq.com/s/z8aJZ14NAc-qXx3Qt4gZLQ

### 页面渲染步骤

### 首页加载缓慢，优化

### 安全

前端安全性措施

- 不要使用 dangerouslySetInnerHtml
- react 自带防 xss
- 用户退出后清理 localStorage
- 用https
- 不要再get请求里存放 username和password

有 src 属性的标签都是可以跨域请求的

比如

- `<img>` 在更改 src 属性的时候就会发请求

- script、iframe、link[rel=stylesheet]，在标签添加到DOM树之后才会发请求（iframe标签可以load不同域的src，但是该iframe下的js代码不能拿到原不同域parent对象的js对象）

- 原生form表单提交中，action设置的 发送请求url是没有跨域限制的

  - 为什么说form表单提交没有跨域限制而 ajax请求有跨域限制：不设target的表单提交只负责发请求，不等待请求结果，post结束之后页面全部刷新，原页面的脚本无法获取新页面中的内容，所以浏览器认为这个是安全的。而ajax是可以读取响应内容的

  - 如何使用 form 表单实现无刷新表单提交：

    - 把 form 提交到本域的一个空iframe 中，让服务器处理完之后跳转到同域的空白页里，并给这个空白页添加返回后的数据

    - 跨域：window.name / window.domain / window.postMessage

    - 当数据接口A 在B空白页面加载数据请求时，会将返回的数据存放在url中，通过解析url的query就能取回返回的数据啦~

      通过监听隐藏iframe的onload事件，就可以触发父页面的callback函数啦~

    - http://www.dengzhr.com/js/1346

#### XSS攻击

网页中某个html内容值是由 url 的 searchParam 设置的，若将searchParam修改为一个 可以引发某些恶意操作的 javascript 语句，那么这个 html 嵌入之后会执行这段代码，从而达到攻击的目的

- 恶意的 js 代码有几种形式：
  - `<script>xxx</script>`：这种情况可以用 escapeHTML(str) ，对特殊字符进行转义，从而让浏览器知道这段字符只是一个文本，而不是需要被执行的真实html语义标签
  - 在标签中进行跳转时，可以设置 `<a href='javascript:js代码'`：浏览器解析过程：只要包含 javascript: ，其后的js代码就会被执行，可以通过构造白名单的方式（即设置一个href跳转时允许的start列表，如['http', 'https']），过滤所有没有意义或者恶意的href 指向

在`<script>`代码执行标签中可能会设置 JSON 数据，JSON数据是不能用 escapeHTML 来转义的，否则会破坏 JSON 数据本身的含义，此时如果在JSON数据中包含一个 `</script>`闭合标签，浏览器就会认为后面的代码为 HTML，从而，可以继续在之后的代码中插入 `<script>` 来执行想要执行的恶意代码

<script>
	var initData = <%=data.toJSON() %>    
</script>

可以自己实现一个HTML的转义库（简易版），如将< 和 > 转换为对应的转义字符

或者直接使用业界通用的转义库

##### 分类

https://excess-xss.com/

- 存储型XSS
  - 攻击步骤：
    - 攻击者将恶意代码提交到目标服务器的数据库中（如论坛发帖）
    - 用户打开目标网站时，网站服务器将恶意代码从服务器中取出，拼接在HTML中返回给客户端（？？？）
    - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    - 恶意代码窃取用户的信息并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作
  - 适用范围：常用于带有用户数据保存功能的网站，比如论坛发帖、用户评论、用户私信等
- 反射型XSS
  - 恶意代码存在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的URL，其中包含恶意代码
    - 用户打开带有恶意代码的URL，**网站服务器**将恶意代码从URL中取出，拼接在URL中返回给浏览器
    - 用户浏览器接到响应后解析执行，混在其中的恶意代码也被执行
    - 同存储型最后一步
  - 适用范围：常用于通过URL传递参数的功能，如网站搜索、跳转等
  - 另：POST方式需要构造表单并诱导用户点击 ？？？？
- DOM-XSS
  - 恶意代码也在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的 URL，其中包含恶意代码。
    - 用户打开带有恶意代码的 URL。
    - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
  - 取出和执行恶意代码完全由 浏览器端完成，为Javascript前端的安全漏洞

##### 预防

- DOM型：
  - 使用 `.textContext` 和 `.setAttribute` 来替代 `.innerHTML`、`.outerHTML`、`document.write()`
  - 技术栈，react，少使用 dangerouslySetInnerHTML
  - 注意那些可以把字符串当做代码运行的部分：
    - DOM中的内联事件监听器：location、onclick、onerror、onload、onmouseover 等
    - <a 标签的 href 属性
    - javascript 代码 setInterval、setTimeout
- 跟服务端相关的两种类型
  - 选取合适的 HTML转义库
  - 注意拼接HTML的操作，尽量使用createElement等行为来生成 dom元素
  - 纯前端渲染？？
    - 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
    - 然后浏览器执行 HTML 中的 JavaScript。
    - JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

#### CSRF攻击

https://www.tuicool.com/articles/7Ff2EbZ

跨站请求伪造，在访问黑客网站时的操作会被操作到其他网站上

- 利用 img、script、iframe 的src标签可以请求跨域资源的特性，通过这些src来请求一些不规范的get请求（本应该是修改数据的post请求但是可能由于安全疏忽写成了get请求）
- post请求处理关键业务，利用 界面原生 form 表单可以跨域提交的特性，再加上空白iframe实现无刷新，可以再用户不知情的前提下实现跨域发送伪造请求

解决办法：

可以使用csrf-token的方式，服务端生成csrf-token，并通过服务端渲染的方式，将其设置到隐藏 form表单中 发送给用户，用户每次提交post请求时都会自动添加这个form表单中的csrf-token，服务端通过验证token即可得知当前请求是不是原站发过来的真实请求

## CDN



# typescript

继承和实现的区别

https://juejin.im/entry/5981c5df518825359a2b9476

# Javascript

https://github.com/mqyqingfeng/Blog

## 基础

关于 == 和 加法运算符，可见 掘金思考题整理md

### Object

Object.getOwnPropertyNames 和 Object.keys() 都是用来获取对象属性名称的方法，区别在于：

- getOwnPropertyNames：只能获取该**对象实例**属性的属性名称，（但是包括所有的 **可枚举属性 和 不可枚举属性**）
- Object.keys：可以获取**对象实例**属性的属性名称，但是只限于**可枚举属性**
- for-in循环：返回所有通过对象可以访问的（**对象实例 或 原型链**）、**可枚举**的属性



### Date

Date.parse(str)：返回一个从**1970-01-01** 到 传入str的日期对象的毫秒数（如果传入日期比1970-01-01小，那么返回一个负数）

## es6

### class

如果父类有方法不想让子类继承，需要怎么做

#### class 是 Function 的语法糖，那么class 和 function有哪些区别

1. class 内部只能有 构造函数constructor、方法、存值取值函数（get\set）、属性表达式（\[:expression]()）

2. class 只能用new 来声明，不能直接按照普通函数调用那样使用

3. class内部自动声明为严格模式

4. class类不存在变量提升（方便“继承”的使用）

5. 类 相当于 实例的原型，所有在类中定义的方法，都会被实例继承

6. 可以定义**静态方法**，static 关键字——该方法只能直接通过类来进行调用（**静态方法中的this 指的是 这个class（即实例原型），而不是实例**

   静态方法可以被继承

7. **静态属性**，定义在 class 上，而不是实例上的属性 ( 只能在class外部定义Class.prop = 1 )

### promise

promise的then

promise 的then函数中是如何获取上次resolve的值的

同一个promise对象a，对此执行a.then 会有什么反应

### async/await

await 具体作用是什么

## es7



## webpack

介绍、loader

## 跨域

https://harttle.land/2015/10/10/cross-origin.html#header-5

同源策略：协议、域名、端口都相同，才可以

- 读取 Cookie、localStorage、indexDB
- 获取DOM 和 JS 对象
- 发送AJAX请求

解决跨域问题的几种方法

1. jsonp：原理：浏览器允许将js、css、img等静态资源分离到另一台独立域名的服务器上，通过这个与当前域名不同的服务器来加载静态资源

   动态创建script，请求一个带参网址来实现通信

   缺点：只能发送get一种请求

2. document.domain + iframe

   - 原理：两个页面通过js设置document.domain为同一主域从而实现同域（仅限于两个页面主域相同，子域不同的情况）
   - 只能获取不同域的 dom 和 js 对象

3. location.hash + iframe

   - 不同域的iframe只能，父窗口设置子窗口的hash值，子窗口不能获取父窗口 js 相关信息
   - 实现方式：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

4. window.name + iframe

   - 原理：name值在不同的域名加载后仍然存在，只要浏览器标签页不关闭，name值就不变
   - 实现方式：可以在window.name中记录想要跨域传输的信息
     - 当请求不同域的信息时，在该被请求文件中设置 window.name  值为想要传递的信息，在当前页面中创建一个iframe，src设置为该被请求文件路径，iframe onload的时候，这个window.name 已经被设置了，之后再将iframe 的src设置为与当前文件同域名的一个空文件，并读取其中的window.name值，从而实现js的通信

5. html5 postMessage

   - 用于解决以下问题
     - 页面和其打开的新窗口之间的消息传输
     - 多窗口之间消息传递
     - 页面与嵌套的iframe消息传递

## canvas

绘图、canvas鼠标事件、判断点在复杂图形内部

## 原理

### instanceof 原型链

https://alexzhong22c.github.io/2017/08/08/js-proto/

实例对象 f 的\__proto__指向原型对象 Foo.prototype，Foo.prototype.constructor 指向构造函数 Foo，由原型链：f.constructor 指向构造函数 Foo

实例对向 obj 的\__proto__ 指向原型对象 Object.prototype, Object.prototype.constructor 指向构造函数 Object，有原型链：obj.constructor 指向构造函数 Object

![1554775214835](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554775214835.png)

1. 构造函数Foo 作为实例对象：每个函数都可以看作是 new Function(xxx)构建的对象

   Foo.\__proto__ = Function.prototype，Function.prototype.constructor = Function 

   => Foo.constructor = Function

2. 原型对象Foo.prototype 作为实例对象：每个对象都可以看作是 new Object() 构建的对象

   Foo.prototype.\__proto__ = Object.prototype,  Object.prototype.constructor = Object

   => Foo.prototype.constructor = **Foo** 因为在Foo.prototype自己内部找到了constructor属性，不需要继承原型链上Object.prototype 的constructor属性

3. 构造函数Object作为实例对象：每个函数都可以看作是 new Function(xxx) 构建的对象

   Object.\__proto__ = Function.prototype,  Function.prototype.constructor = Function

    => Object.constructor = **Function**

4. 原型对象Object.prototype作为实例对象：Object.prototype.\__proto__ = null

5. 构造函数Function作为实例对象：每个函数都可以看作是 new Function(xxx) 创建的对象

   Function.\__proto__ = Function.prototype

6. 原型对象Function.prototype 作为实例对象：每个对象都可以看作是 new Object(xxx) 创建的对象

   Function.prototype.\__proto__ = Object.prototypes

Array的prototype是否可以修改：不可以，所有js内置的构造函数的prototype都不能改

### 创建对象

#### 使用原型模式创建对象

```javascript
function Person() {
    
}
Person.prototype = {
    constructor: Person, // Person.prototype中的constructor指向Person构造函数
    name: 'zwq',
    age: 24,
    job: 'student',
    sayName: function() {
        console.log('hello')
    }
}
```

以上代码中有一个缺点是：用户自定义的对象属性，默认enumerable属性为true，也就是说 constructor会变成可遍历属性（for...in 和 Object.keys() 都会拿到这个属性），这与其默认行为是不符的，所以使用

```javascript
Object.defineProperty(Person.prototype, 'constructor', {
    value: Person,
    enumerable: false
}) // 用这个定义方法来替代Person.prototype中直接定义constructor属性的方法
```



可以在声明实例变量之后修改其原型对象的一些属性，但是如果是用Person.prototype = {}来对它的原型对象进行重写，那么原先声明的实例变量只能取到旧的原型对象的属性，新原型对象的属性是取不到的

```javascript
function Person(){}
const p1 = new Person()
Person.prototype.sayName = function() {
    console.log('hello')
}

p1.sayName(); // hello
Person.prototype = {
    name: 'zwq',
    callName: function() {
        console.log(this.name)
    }
}
p1.callName() // error
```

也就是说，使用重新赋值的方式会切断原先声明的变量和Person.prototype 之间的联系，旧的变量引用的还是旧的prototype



原型模式的关键在于：**共享**，在prototype上定义的引用类型的变量都是共享的，对于函数来说它可以节省开销，但是对于Array、Object这样的引用类型变量作为原型value时，我们在一个实例变量中对它的Array进行操作（如push\pop\shift等会影响原数组的操作），那么另一个实例变量的对应属性由于指向同一个内存地址，会感应到这个变化，

通常我们在新实例化一个变量的时候是希望给它分配一个不被别人影响的内存空间，而不是和其他实例变量一起共享某些属性



#### 解决办法：混合使用原型模式和组合模式

就是把需要共享的属性放到Prototype里，而把不需要共享的属性放到Person自己的构造函数里

```javascript
function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype = {
    sayName: function() {
        console.log(this.name)
    }
}
Object.defineProperty(Person.prototype, 'constructor', {
    enumerable: false,
    value: Person,
})
```

#### 更加面向对象的对象创建模式：动态原型模式

```javascript
function Person(name, age) {
    this.name = name
    this.age = age
    if (typeof this.sayName !== 'function') {
        Person.prototype.sayName = function() { // 这里只能用这种方式定义，不能用对象字面量方式重写，因为重写之后会切断已存在实例对象和旧的原型对象之间的关系
            console.log(this.name)
        }
    }
}
```



### 继承

#### 经典继承

```javascript
function SuperType() { 
	this.color = ['red', 'blue', 'green']
}

function SubType() {
    // 继承关键代码
    SuperType.call(this)
}

var instance1 = new SubType()
instance1.colors.push('black')
console.log(instance1.colors); // red, blue, gree, black

var instance2 = new SubType()
console.log(instance2.colors); // red, blue, green
```

这个继承模式相当于把SuperType实例里的所有属性和方法都复制一份到SubType里

好处：每个SubType都拥有自己独有的一份空间，引用类型变量不会发生共享的问题

缺点：

1. 没有继承原型链上的属性和方法，无法使用instanceof 判断原型链
2. 可以共享的函数定义没有共享，而是创建了两个一模一样的函数

####  组合继承

原理：使用原型链实现对原型属性和方法的继承，使用构造函数实现对实例属性的继承

```javascript
function SuperType(name) {
    this.name = name
    this.colors = ['red', 'green', 'blue']
}

SuperType.prototype.sayName = function() {
    alert(this.name)
}

function SubType(name, age) {
    // 继承父构造函数的实例属性
	SuperType.call(this, name) // 第二次调用父构造函数
    this.age = age
}
// 继承父原型对象的属性和方法
SubType.prototype = new SuperType() // 第一次调用父构造函数
SubType.prototype.constructor = SubType

const child = new SubType(); 
```

优点：可以使用 instanceof / isPrototypeOf() 判断原型链上的对象属性，而且不会共享不想被共享的对象的和方法

缺点：父原型对象的构造函数会被调用两次，

- 第一次是在 构建原型链的时候，SubType的prototype（原型对象）上 创建了一个SuperType 实例，那么SubType.prototype 会有一个 name 和 colors 的属性，
- 而在初始化 child 对象时，new SubType 在SubType 的构造函数中 又调用了一次 SuperType的构造函数，在SubType对象上添加了一个name 和colors 的属性
- 

#### 原型继承

原理：借助原型基于已有的对象来创建新的对象

```javascript
function object(o) {
	var F = new Function(){}
    F.prototype = o
    return new F()
}
// 这段代码作用相当于
var B = object(A)
var B = Object.create(A, {
    name: {
        value: 'xxx'
    }
})
// Object.create 方法的第二个参数格式与 Object.defineProperties 相同
```

从本质上讲，object对传入的对象进行了一次浅复制

适用于简单考虑对象复制的继承

缺点：原型模式继承的对象始终共享引用类型的值

#### 寄生继承

原理：类似寄生构造函数和工厂模式，即创建一个用户封装继承过程的函数（依赖于原型继承实现继承）

```javascript
function createAnotherPerson(person) {
    var clone = object(person)
    clone.sayHi = function() {
        console.log('hi')
    }
    return clone
}
```

当主要考虑对象不是自定义类型和构造函数的情况下，寄生式继承是可以使用的

缺点：

1. 原对象person 的引用类型被所有继承对象所共享
2. 当需要为继承对象添加多个函数时，继承对象实例不能共享函数，效率较低

#### 寄生组合式继承

组合式继承的缺陷：父类的构造函数被执行了两遍，给SubType.prototype 和 subType实例对象都添加了对应的属性，但是其实只有一个就可以了

寄生式继承的缺陷：父类的引用类型属性被所有继承对象共享，改一个就相当于改了全部；而且为继承对象添加函数时函数无法共享

寄生组合式继承：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法

基本思路：不必为了指定子类型的原型而调用超类的构造函数，我们只是想要一个超类原型对象的副本，本质上就是使用寄生式继承来继承超类的原型，然后再将结果指定给子类型

```javascript
function inheritPrototype(subType, superType) {
    var prototype = Object.create(superType.prototype) // 创建对象
   	prototype.constructor = subType // 增强对象
    subType.prototype = prototype // 指定对象
}
// 使用这种方式实现的继承，不会再构造继承链的时候调用超类的构造函数，也就是说不会再subType.prototype 对象上添加超类的构造函数中的属性
// 调用方式
function SuperType(name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function() {
    console.log(this.name)
}

function SubType(name, age) {
	SuperType.call(this, name)  // 调用超类的构造函数，在子类的实例对象上添加它应该持有的自己的非共享属性和方法
    this.age = age
}

inheritPrototype(SubType, SuperType) // 这里不会调用超类的构造函数

```

优点：

1. 只调用了一次SuperType 构造函数，并且避免了在SubType.prototype 上创建不必要的属性

2. 保持原型链不变

### 块级作用域

const一个函数，能否修改这个函数的this？

答：函数this的指向，如果没有绑定，在调用的时候确定，但是也可以对它进行this指向的修改（如bind等操作，这个时候会返回一个新的函数放到堆内存里，对原函数没有影响），和const无关

## 具体问题

### 大数相加（包含负数）

### 实现一个简单的Promise

### 数组去重，里面有对象，数组

### 深拷贝的两种方法

（对象、数组、函数

### 实现reduce

### 金额加逗号



# 算法

https://github.com/azl397985856/leetcode

https://www.qiujiawei.com/tag/leetcode/

## 排序

https://www.cnblogs.com/onepixel/articles/7674659.html

### 快排

### 冒泡



## 动态规划

https://www.zhihu.com/question/23995189/answer/613096905

如何找到两个数组的最长相同子序列

### 其他问题

抽牌算法

# css

如何用css实现一个左右两栏高度与中间块高度同高的布局

### 布局

flex、grid、position、float

#### 重排和重绘

https://juejin.im/post/5a9372895188257a6b06132e

哪些操作会触发重排（reflow）：

- **盒模型**相关属性：width、height、margin、display、border
- **定位属性及浮动**相关属性：position、float、top
- **改变节点内部文字结构**：text-align、overflow、font-size、vertical-align、line-height
- 调整窗口大小
- style变动
- **元素内容**变化（尤其是输入控件）
- dom操作
- **css伪类**
- 计算元素的offsetHeight、offsetWidth、clientWidth、clientHeight、width、height、scrollHeight、scrollWidth

#### 绝对定位和相对定位的区别



# react

### 和jquery的区别

### diff的过程（为什么还需要shouldComponentUpdate）

- renderTree同层比较
- 三种操作：Add、Remove、Move（通过key对比实现）

为什么还需要 shouldComponentUpdate？

因为js diff运算也是耗费资源和时间的，如果可以根据prop或者state判断不需要修改，可以省下 diff运算的资源耗费

### react connect 和 Provider的作用是什么

### react页面切换动画怎么做

### PureComponent 和 普通组件的区别是什么

### setState异步更新 

在React中，**如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state**。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。

在React的setState函数实现中，会根据一个变量**isBatchingUpdates**判断是直接更新this.state还是放到队列中回头再说，而***isBatchingUpdates***默认是false，也就表示setState会同步更新this.state，但是，有一个函数**batchedUpdates**，这个函数会把***isBatchingUpdates***修改为true，而当React在调用事件处理函数之前就会调用这个**batchedUpdates**，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。

### react生命周期

#### 15版本

![img](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageslim)

#### 16版本

![1553688093737](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1553688093737.png)

- constructor：初始化state、给实例绑定 事件处理函数
  - constructor中不应该调用 setState
- **static** getDerivedStateFromProps(nextProps, prevState)
  - 在 render 之前被调用
  - 在prevState中存储想要获取的prevProp，用来跟nextProp比对
  - 返回值为更新之后的state（整个替换）
  - **只能执行纯函数操作**：输出完全依赖于输入，不能执行副作用过程
- shouldComponentUpdate(nextProps, nextState)
  - 接收到新的state或props时调用，默认返回true
  - 首次render和forceUpdate()过程不会调用这个生命周期函数
  - return false 只能阻止当前组件重新render，不能阻止子孙组件重新render
  - 如果是为了“阻塞”某次更新的话，应该考虑使用 PureComponent，它会对props和state做一次浅比较
- getSnapshotBeforeUpdate(prevProps, prevState)
  - 最近一次render的结果要被提交给dom之前调用，可以在DOM更新前获取一些信息
  - 返回值会被当作第三个参数传递给 componentDidUpdate
  - 需要返回null或一个默认值
- componentDidMount
  - 发送请求获取数据
  - 注册事件（需要在unmount中取消事件）
  - 在这里**立即**调用setState时，render会被调用两次，但真正实际的dom更新只有一次？？？
- componentDidUpdate(prevProps)
  - 更新完成后操作DOM节点
  - 对比props之后可以发送请求获取数据
- componentWillUnmount



#### 为什么说 componentWillUpdate 和 componentWillReceiveProps 会被调用多次，而componentDidUpdate 只会被调用一次

react 16 Fiber架构，两个阶段

- reconcile阶段：可以被打断
  - prop/state更新->生命周期函数 -> 虚拟dom -> diff -> 修改真实dom
  - 可能被调用的生命周期函数：
    - componentWillMount
    - componentWillUpdate
    - componentWillReceiveProps
    - shouldComponentUpdate
- commit阶段：不可以被打断
  - 可能被调用的生命周期函数
    - componentDidUpdate
    - componentDidMount
    - componentWillUnmount

Fiber 是比 thread 更细的粒度，js是单线程的，fiber就是让react在reconcilation阶段，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务需要更新

- 有的话，做紧急任务，当前分片的更新过程作废
- 没有的话继续执行下一个分片的更新任务

### key的作用

## react-router

如何自己实现一个router，如何监听路由变化

### hash API

### history API

### ImmutableJS 的实现

https://juejin.im/post/5b9b30a35188255c6418e67c

用树来存储

持久化数据结构：每次修改后都会得到一个新的版本，而且旧版本可以被完整保留

1. 结构共享：每次更新state时会创建一个新的根节点，对于有修改的部分，把相应路径上的所有节点重新生成，对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是`结构共享`。这样每次操作同样会获得一个全新的版本（根节点变了，新的`a`!==旧的`a`），历史版本可以完好保留，同时也节约了空间和时间。

![1554811844250](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554811844250.png)

2. 一个Map如何成为持久化数据结构：Vector Trie

   例子：假如我们有一个 map ，key 全都是数字（当然你也可以把它理解为数组）`{0: ‘banana’, 1: ‘grape’, 2: ‘lemon’, 3: ‘orange’, 4: ‘apple’}`，为了构造一棵二叉`Vector Trie`，我们可以先把所有的key转换为二进制的形式：`{‘000’: ‘banana’, ‘001’: ‘grape’, ‘010’: ‘lemon’, ‘011’: ‘orange’, ‘100’: ‘apple’}`

   添加一个`5:'watermelon'`

   ![1554812461507](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554812461507.png)

   1. `5: 'watermelon'` 转变为 `'101': 'watermelon'`
   2. 创建新的根节点 01
   3. 重新构造其右子树，左子树仍指向旧的左子树指针

   当map的key值不为 数字的时候，immutable实现了一套 hash 的机制，将不是数字的key值转换为数字对象（对于number、string、object、function类型的key值有不同的处理，

   - number类型则直接对这个number进行hash（number / 0xffffffff 并对这个结果进行异或，直到 number < 0xffffffff 为止），

   - string类型则会缓存一个cachedString对象，如果string键名大于某个最小长度，则从cachedString中查找有没有这个string键名对应的hash数，如果没有的话创建并放进去

     如果string键名长度小于这个最小长度，则直接生成一个hash数并返回给用户

   - object：weakMap（obj的值设置为hash之后的数值）或其他实现？？？

   - function：toString之后走string的流程

   实际情况中immutalbe map 的实现并不是二叉树，因为二叉树会在数据量变大时嵌套层级变深，实际实现中每个节点的数组长度为 32（位分区）

   `位分区`是建立在`数字分区`的基础上的，所有以2的整数次幂（2，4，8，16，32…）为基数的`数字分区`前缀树，都可以转为`位分区`。基于一些位运算相关的知识，我们就能避免一些耗时的计算。

   `数字分区`把 key 拆分成一个个数字，而`位分区`把 key 分成一组组 bit。以一个 32 路的前缀树为例，`数字分区`的方法是把 key 以 32 为基数拆分（实际上就是 32 进制），而`位分区`是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二进制位 。实际上就是把 32 进制数当成 2 进制进行操作，这样原本的很多计算就可以用更高效的位运算的方式代替。因为现在基数是 32，即`radix`为 32，所以前面的式子现在是`key / 32level - 1 % 32`，而既然`32 =``25`，那么该式子可以写成这样`key / 25 × (level - 1) % 25`。根据位运算相关的知识我们知道`a / 2n === a >>> n `、`a % 2n === a & (2n - 1) `。这样我们就能通过位运算得出该式子的值。

   **如果你对位运算不太熟悉的话，大可不看上面的式子，举个例子就好理解了**：比如数字`666666`的二进制形式是`10100 **01011** 00001 01010`，这是一个20位的二进制数。如果我们要得到第二层那五位数`01011`，我们可以先把它右移`>>>`(左侧补0)10位，得到`00000 00000 10100 **01011**`，再`&`一下`00000 00000 00000 11111`，就得到了`**01011**`。

   

### draftJS 的实现



## 具体问题

如果有个组件嵌套层级较深，数据怎么获取比较好



