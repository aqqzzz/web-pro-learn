面试问题

# 网络

## cookie 和 session 

### cookie

#### 字段

服务器向客户端设置 Cookie：

`Set-Cookie: <cookie-name>=<cookie-value>;(可选参数1);(可选参数2)`

参数字段：

`Expires`：cookie的最长有效时间，若不设置则Cookie生命期与会话期相同

`Max-Age`：cookie生成后失效的秒数

`domain`：指定cookie可以送达的主机名，若设置的是一级域名，那么二级域名也可以获取对应的域名

`path`：指定URL

`Secure`：必须使用 SSL 或 HTTPS 协议的时候，cookie才能被发回服务器

`Http-only`：设置浏览器不能使用 javascript 获取cookie对象

#### 访问方式

cookie的访问方式有两种，

- 通过js访问，document.cookie返回当前页面的可用cookie，但是这种情况下很容易被黑客窃取cookie信息，可以通过生成cookie时设置 HttpOnly 属性为true，限制cookie只能在http发送请求时携带
- 设置cookie时会设置domain域名，当用户向这个域名发送请求时，浏览器会自动去自己存储的cookie列表中（这个列表包含所有cookie，包含httponly的，而且同一域名下可能会有多个cookie），查找到当前域名下的所有cookie，然后加到 http请求中发送给服务器（如果是fetch请求的话需要设置 withCredentials:true 浏览器才会在http请求中加cookie），服务器收到后查找最匹配的cookie并进行响应操作（？？？？是客户端把所有cookie都发送给服务器吗）
  - 一般cookie是由服务端生成的，服务端通过在发送给客户端的响应报文头中设置 set-cookie 字段来设置cookie
  - 客户端自己可以通过设置 document.cookie 来**添加**一个新的cookie（不会覆盖已有cookie，除非设置cookie 的 name、value、domain、path 都和一个已存在的cookie重复）

#### 和session的区别

1. session 是在服务器端保存的数据结构，用来跟踪用户状态。Cookie是在客户端保存用户信息的一种机制，用来记录 用户的一些信息（是session的一种实现方式）
2. session更安全
3. 访问增多时，session 会较大地占用服务器的性能。考虑减轻服务器性能的方面，应当适时使用 Cookie
4. session 依赖 session Id，session id 是存储在cookie 中传输的，如果禁用了cookie， session也会失效，可以使用 localStorage + header 和 url 中进行传输

https://harttle.land/2015/08/10/cookie-session.html

cookie和session都不是绝对安全的，只是session可以更有效地防止恶意用户对重要信息进行篡改之后，再对服务器发送篡改信息之后的攻击（但是它们对于预防重放攻击的处理办法都是相通的），因为cookie是明文，而session是服务器生成的哈希串，而且还带了checksum校验

防止重放攻击：对cookie内容进行加密，加入时间戳格式（或服务器和客户端商定的随机数递增模式），对内容进行加密之后再传输（保证每次加密的密文都不一样）

## localStorage 和 sessionStorage 和 cookie

cookie：4kb 左右，用于存储登录信息等

localStorage：HTML5 新特性，为一个给定的源（origin）维持一个独立的存储区域，该存储区域是长时间可用的，即使用户关闭了浏览器之后重新打开，数据仍然存在

sessionStorage：为一个给定的源（origin）维持一个独立的存储区域，将一部分数据在当前会话中保留下来，刷新页面数据依旧存在，但当页面关闭后，sessionStorage中的数据就会清空

localStorage 和 sessionStorage 在window中返回的都是一个 Storage 对象，可以使用相同的方法操作这些对象

应用：

localStorage 可以用于在两个同源的浏览器tab页面之间传递信息，只要更新localStorage，则两个tab页面是共享同一个localStorage的

可以 使用 `window.addEventListener('storage', function(e) {})` 来监听storage改变的事件，并对其作出响应（具体storage内容可以从e.storageArea中获取）

| 特性           | Cookie                                                       | localStorage                                                | sessionStorage                               |
| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------- |
| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除 |
| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   |                                              |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |
| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |

**安全性考虑**

cookie、localStorage 和 sessionStorage 是可以通过控制台进行修改的，所以要注意代码没有 XSS 注入的风险

storage对象需要考虑其大小显示，不能无限制添加，特别是localStorage，由于是永久性存储，我们需要随手进行removeItem 或者 clear 对其进行清除，缓解方案：使用压缩方式对数据进行压缩，同时取数据的同时也要进行解压

### 异同（localStorage 和 sessionStorage）

**相同点**：

1. 存储大小均为5M左右
2. 都有同源策略的限制
3. 仅在客户端中保存，不参与和服务器的通信

**不同点**：

1. 数据生命期不同：localStorage永久有效，sessionStorage仅在当前会话下有效，关闭页面或浏览器之后被清除

2. 作用域不同：谁拥有数据的访问权

   localStorage：**同一个浏览器内**，同源文档之间共享 localStorage 数据

   sessionStorage：只有同一个tab页面内才可以共享数据，如果是同源文档，但是处于同一浏览器的不同tab页，sessionStorage是不能共享的；而同一个tab中，不同iframe之间，是可以共享sessionStorage的

https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API

## HTTP 

### HTTP 是什么

Hypertext Transfer Protocol 超文本传输协议

HTTP是一种能够获取HTML这样的网络资源的通讯协议，是web进行数据交换的基础，是一种 client-server协议，也就是说，请求通常是由浏览器这样的接收方发起的

HTTP的基本性质：

- 简单
- 可扩展：HTTP headers
- 无状态，有会话
  - 无状态：同一个连接中，两个执行成功的请求之间是没有关系的
  - 有会话：HTTP的头部扩展，cookies，使用cookie可以创建有状态的会话
- 连接：一个连接本质上是传输层定义的，与HTTP无关，HTTP并不需要其底层的传输协议的面向连接的，只需要它是可靠的

### HTTP状态码

#### 301 和 302 的区别

- 定义：
  - 301：永久重定向
  - 302：暂时重定向
- 浏览器的表现
  - 301：浏览器会把这个重定向缓存起来，下一次就不查询，直接请求重定向之后的网址（类似强缓存）
  - 302：只是暂时性的，所以浏览器每次都会请求原网址
- 搜索引擎的表现：
  - 301：类似继承遗产，旧网址的搜索排名会直接转给新网址，而且搜索引擎收录的会换成 新的网址对应新网址的内容
  - 302：旧的网址对应新的内容，搜索排名不会转移

### 为什么 HTTPS 网站不能发送 HTTP 请求

混合内容：在HTTPS网站中使用HTTP发送了请求（script 或者 img src 或者 请求），http请求没有安全保障，可能会被中间代理人或其他恶意网站劫持而对用户的网站造成伤害

- 通过简单的script引入不安全的http请求：攻击者可以将代码注入返回的内容，并控制整个页面
- 通过请求（XMLHttpRequest 或 fetch）获取的数据用于更新innerHTML

Mixed Content：HTTPS网站中使用HTTP加载的资源

- IE：默认加载图片类 mixed content，其他根据用户选择来加载
- 现代浏览器：
  - Optionally-blockable：危险较小，即使被中间人篡改也没有大问题的资源，现代浏览器会默认加载这些资源，并在控制台输出警告
    - 通过 `<img>` 加载的图片资源
    - 通过`<video> ` / `<audio>` 和 `<source>` 标签加载的视频或音频
    - 预读资源
  - Blockable：除以上外全都是Blockable的混合资源，现在浏览器不加载，并在控制台输出Error（Javascript、Css等）

### HTTP 和 HTTPS 的区别，主要用了什么加密算法

1. HTTPS协议需要CA证书

2. HTTP协议运行在TCP上，所有传输的内容都是明文

   HTTPS协议运行在SSL/TLS上，SSL运行在TCP上，所有传输内容经过加密

3. 端口不同：HTTP：80、HTTPS：443

HTTPS网站 **非对称加密**的过程

https://segmentfault.com/a/1190000005597589

1. 服务器使用RSA（非对称密钥生成技术）生成两个不同的秘钥k1和 k2， 使用k1加密的消息只能用 k2 解开，而是用k2 加密的消息 只能用 k1 解开，生成之后，服务器将k1 作为公钥发送给客户端
2. 客户端接收到这个公钥，并自己生成一个新的秘钥 key，使用服务端发送的公钥 k1 加密这个密钥 key 之后，发送给服务端
3. 服务端接收到加密的 密钥 key， 使用自己的私钥 k2 将其解密，获得客户端-服务器通信的真正对称密钥 key
4. 之后的数据传输使用 key 进行加密和解密

其实HTTPS网站非对称加密，只是使用非对称的加密方式来传输真正的对称密钥，因为非对称的加密解密过程十分耗时，而对称加密则能减少加密解密的时间

而单纯的对称加密又会在传输密钥的过程中有密钥泄露的危险，

所以使用 非对称是比较安全的做法

问题：

就算使用了非对称加密，HTTPS网站还是无法避免**中间人攻击**，中间人可以在客户端和服务器发送 非对称密钥的时候，就劫持服务端 的k1 密钥，并假装自己是客户端，使用k1 生成自己的秘钥 key2，并将其发送给服务器，并把这个密钥也发送给客户端，让客户端和服务器都认为自己与对方完成了密钥交换，那么整个传输过程就变成了 服务器 （加密）-> 中间人（明文） -> 客户端（加密），中间人可以获取双方发送的请求的具体内容是什么

HTTPS避免中间人攻击的方式：**CA证书**，客户端发送请求时服务端返回证书和公开密钥（公开密钥作为证书的一部分），只有通过客户端验证的证书，客户端才会使用这个公开密钥（这个公开密钥就是服务端生成的 两个非对称密钥中的一个，需要提前向CA认证机构申请，并确认这个公开密钥的合法性，之后这个公开密钥直接由CA证书传递）来生成对称加密的 key，并发送给服务器

https://www.cnblogs.com/handsomeBoys/p/6556336.html

各个网站服务商可以向 CA 申请证书，使得他们在建立安全连接时可以带上 CA 的签名。而 CA 得安全性是由操作系统或者浏览器来认证的。

你的 Windows、Mac、Linux、Chrome、Safari 等会在安装的时候带上一个他们认为安全的 CA 证书列表，只有和你建立安全连接的网站带有这些CA的签名，操作系统和浏览器才会认为这个链接是安全的，否则就有可能遭到中间人攻击。

一旦某个 CA 颁发的证书被用于的非法途径，那么这个 CA 之前颁发过的所有证书都将被视为不安全的，这让所有 CA 在颁发证书时都十分小心，所以 CA 证书在通常情况下是值得信任的。

### HTTP1.0、HTTP1.1、HTTP2.0

#### HTTP1.0和HTTP1.1的区别

1. **缓存处理**：
   - HTTP1.0：if-Modified-since，Expires
   - HTTP1.1：ETag、If-None-Match、Last-Modified、If-Unmidified-Since

2. **带宽优化及网络连接**
   - HTTP1.0：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
   - HTTP1.1：请求头引入 range域，允许之请求资源的某个部分（返回206）
3. **错误通知**（状态码）HTTP1.1新增
   - 409：conflict 请求资源与资源的当前状态发生冲突
   - 410：Gone 服务器上某个资源被永久性删除
4. **Host头处理**
   - HTTP1.0：认为每台服务器绑定一个唯一的IP地址
   - HTTP1.1：服务器中产生 虚拟主机，一个物理服务器上可以有多个虚拟主机，并且它们共享一个IP地址。所以HTTP1.1 的请求消息中必须用Host头域来指定 请求的主机名
5. **长连接**
   - HTTP1.0：默认关闭长连接，只有设置`Connection: keey-alive` 才能开启长连接
   - HTTP1.1：默认开启长连接，只有设置`Connection: close` 才能关闭连接
   - 长连接的好处：
     - 在一个TCP连接上可以传送多个HTTP请求和响应
     - 减少建立和关闭TCP的时延
     - 减少慢启动时延

#### HTTP2.0 和 HTTP1.x相比的新特性

- **二进制格式**。

  - HTTP1.x解析基于文本，需要考虑更多健壮性场景
  - 2.0只使用二进制

- **多路复用**：连接共享

  一个连接上可以有多个request，每个request可以随机混杂在一起，接收方可以根据request的id 将request再归属到各自不同的服务端请求里

- **header压缩**：使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields 表

- **服务端推送**：可以把客户端需要的资源伴随 index.html 一起发送到客户端，省去了客户端重复请求的步骤

#### HTTP2.0 多路复用 和 HTTP1.x中的长连接复用的区别

- HTTP1.0：一次请求-响应，建立一个连接，用完关闭（每个请求都要建立一个连接）
- HTTP1.1：若干个请求**串行化单线程**处理，后面的请求等待前面请求返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞——线头阻塞
- HTTP2.0：多个请求可以同时在一个连接上**并行**执行，一个请求耗时严重不会影响其他连接的正常执行

### 缓存 cache-control



### HTTP事务的时延

1. DNS解析：如果最近没有访问过这个URL（即缓存中没有这个URL）
2. TCP事务时延导致HTTP事务时延

### CA证书是什么，如何判定合法

由CA认证机构签发的一种身份认证

## TCP

### TCP事务的时延

1. TCP连接握手时延

2. TCP延时确认机制造成的时延：

   延时确认：每个TCP报文段到达接收方的时候，接收方都会回送一个ack报文给发送方。而延时确认就是搞一个缓冲区，把ack报文放进去，当接收方这边有需要发送给发送方的数据的时候，把ack报文放进去 “捎带”给发送方，如果一直没有数据需要发送，那么会设置一个超时时间，超过这个时间就会单独把ack报文发回去

   HTTP具有双峰特征的请求 - 应答行为降低了捎带信息的可能，当希望有相反方向回传分组的时候，偏偏没有那么多。所以延迟确认算法会引入很大的时延

   为什么延时确认会引入时延？TCP滑动窗口

   

3. TCP慢启动

   TCP连接刚刚建立的时候会有这种策略

   限制一个TCP端点在任意时刻可以传输的分组数，每成功接收一个分组，发送端就有了发送另外两个分组的权限（这个时候是需要确认上一个tcp之后才能发送下一个）+——打开拥塞窗口（调谐）

   但是这个传输分组的数量是有上限的，到达上限之后就不需要重新确认了

4. Nagle算法

   - 充分利用带宽，鼓励每次tcp报文都发送全尺寸的段
   - 将小尺寸的分组数据放在缓存区
   - 只有接收到上一次tcp请求的ack，才能将缓存区中的内容发出去
   - 和 延时确认算法一起使用时，会造成每个tcp请求都被延时

### TCP请求建立 三次握手，是否每次请求都需要三次握手

TCP三次握手：SYN-SEND——SYN-RCVD——ESTABLISHED

TCP四次挥手：FIN_WAIT_1——CLOSE_WAIT——LAST_ACK————TIME_WAIT（如果最后一个确认包没有发送成功，需要重发）——CLOSED

https://hit-alibaba.github.io/interview/basic/network/TCP.html

HTTP1.0协议是每次请求都要建立一个新的TCP连接，但是可以通过设置 keep-alive 让客户端和服务器来保持连接，这样下次发送请求时就不需要重新建立TCP连接了（HTTP1.1 默认为持久连接，HTTP2.0 多路复用）

## 性能优化

### 从一个url页面到页面显示步骤

https://mp.weixin.qq.com/s/z8aJZ14NAc-qXx3Qt4gZLQ

### 页面渲染步骤

https://juejin.im/post/5ca0c0abe51d4553a942c17d

### composite的过程

http://taobaofed.org/blog/2016/04/25/performance-composite/



1. Nodes -> Layout Object，每个node节点对应一个layout object，layout object 知道如何在屏幕上绘制 node 的内容

2. Layout Object -> Paint Layer：

   相同坐标空间的 layoutObjects 属于同一个 paint layer（层叠上下文），paint layer 保证页面元素以正确的顺序合成，这样才能正确地展示 半透明元素 和 元素的重叠等。

   满足条件的 layoutObject 一定会为它创建 paint layer

   - 根元素
   - position 为 relative \ absolute \ fixed \ sticky
   - 透明元素 opacity < 1
   - transform 

3. Paint Layer -> Graphic Layers

   合成层拥有单独的Graphic Layers，其他不是 合成层的 Paint Layer，和第一个拥有Graphic Layer 的父层共用一个（合成层有 Graphic context，是由GPU渲染的）

   如何让一个Paint layer 成为一个 合成层：

   - video
   - video 上的控制元素
   - will-change 属性为 opacity \ transform \ top \ left \ bottom \ right（top、right等需要设置明确的定位position属性，如 relative）
   - translateZ() （3D transform）
   - 层重叠现象（即当前 Paint Layer 和 其同层的 Graphic Layer 有重叠现象时，当前Paint Layer也需要提升为一个合成层，否则它会跟 父级的合成层合并而造成重叠样式的错误）
     - 重叠或部分重叠在一个**合成层**之上
     - 假设重叠在一个 合成层之上：比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的，和这个CSS动画 同层的兄弟元素会被提升为一个单独的 合成层

4. 层压缩：由于层重叠会产生很多的 Graphic Layer，而每个 合成层都要消耗 CPU 和 内存资源

   多个渲染层同一个合成层重叠的时候，这些渲染层会被压缩到一个 Graphic Layer 中

5. 应用：合成层不会影响其他元素的绘制，可以用来提升动画元素的层级，从而减少绘画元素改变而影响同层其他元素repaint（甚至reflow）的开销

   可以使用 will-change: transform 或 transform: translateZ(0) 来提升

   ![1554978407684](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554978407684.png)

### 前端性能优化

应该结合 页面展示过程来说明

#### 网络

涉及到网络的过程有：

- DNS解析
- TCP连接
- HTTP请求/响应

针对各部分的优化策略有：

- DNS：DNS缓存和prefetch（不是很了解，需要再看）

- TCP连接：握手耗时，拥塞控制与调谐

- HTTP：

  - 减少请求次数
  - 减少单次请求所花的时间

  也就是 “压缩” 和 “合并”

  - webpack部分：这里会涉及到webpack的一些优化操作，对webpack还不是很熟，需要了解之后再来补充 // TODO
  - 图片部分：
    - CSS雪碧图
    - Base64编码图片：通常用来编码一些比较小的需要高精度的图片，base64编码格式的图片是可以直接被html理解的，一般情况下我们在`<img src='xxx'/>` 中，在src中使用普通的图片url地址时，浏览器会向服务器发请求去请求这个图片，而如果我们可以把这个图片转换成base64 格式，再设置到src中，就不需要发请求而可以直接显示了
      - 缺陷：
        - 图片压缩后大小为源文件的 3/4 ，没有其他格式的图片压缩效率好
        - base64加密解密需要时间

#### 存储

- HTTP 缓存
- cookie、web Storage、indexexdDB



### 首页加载缓慢，优化

### 安全

前端安全性措施

- 不要使用 dangerouslySetInnerHtml
- react 自带防 xss
- 用户退出后清理 localStorage
- 用https
- 不要再get请求里存放 username和password

有 src 属性的标签都是可以跨域请求的

比如

- `<img>` 在更改 src 属性的时候就会发请求

- script、iframe、link[rel=stylesheet]，在标签添加到DOM树之后才会发请求（iframe标签可以load不同域的src，但是该iframe下的js代码不能拿到原不同域parent对象的js对象）

- 原生form表单提交中，action设置的 发送请求url是没有跨域限制的

  - 为什么说form表单提交没有跨域限制而 ajax请求有跨域限制：不设target的表单提交只负责发请求，不等待请求结果，post结束之后页面全部刷新，原页面的脚本无法获取新页面中的内容，所以浏览器认为这个是安全的。而ajax是可以读取响应内容的

  - 如何使用 form 表单实现无刷新表单提交：

    - 把 form 提交到本域的一个空iframe 中，让服务器处理完之后跳转到同域的空白页里，并给这个空白页添加返回后的数据

    - 跨域：window.name / window.domain / window.postMessage

    - 当数据接口A 在B空白页面加载数据请求时，会将返回的数据存放在url中，通过解析url的query就能取回返回的数据啦~

      通过监听隐藏iframe的onload事件，就可以触发父页面的callback函数啦~

    - http://www.dengzhr.com/js/1346

#### XSS攻击

网页中某个html内容值是由 url 的 searchParam 设置的，若将searchParam修改为一个 可以引发某些恶意操作的 javascript 语句，那么这个 html 嵌入之后会执行这段代码，从而达到攻击的目的

- 恶意的 js 代码有几种形式：
  - `<script>xxx</script>`：这种情况可以用 escapeHTML(str) ，对特殊字符进行转义，从而让浏览器知道这段字符只是一个文本，而不是需要被执行的真实html语义标签
  - 在标签中进行跳转时，可以设置 `<a href='javascript:js代码'`：浏览器解析过程：只要包含 javascript: ，其后的js代码就会被执行，可以通过构造白名单的方式（即设置一个href跳转时允许的start列表，如['http', 'https']），过滤所有没有意义或者恶意的href 指向

在`<script>`代码执行标签中可能会设置 JSON 数据，JSON数据是不能用 escapeHTML 来转义的，否则会破坏 JSON 数据本身的含义，此时如果在JSON数据中包含一个 `</script>`闭合标签，浏览器就会认为后面的代码为 HTML，从而，可以继续在之后的代码中插入 `<script>` 来执行想要执行的恶意代码

<script>
	var initData = <%=data.toJSON() %>    
</script>

可以自己实现一个HTML的转义库（简易版），如将< 和 > 转换为对应的转义字符

或者直接使用业界通用的转义库

##### 分类

https://excess-xss.com/

- 存储型XSS
  - 攻击步骤：
    - 攻击者将恶意代码提交到目标服务器的数据库中（如论坛发帖）
    - 用户打开目标网站时，网站服务器将恶意代码从服务器中取出，拼接在HTML中返回给客户端（？？？）
    - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    - 恶意代码窃取用户的信息并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作
  - 适用范围：常用于带有用户数据保存功能的网站，比如论坛发帖、用户评论、用户私信等
- 反射型XSS
  - 恶意代码存在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的URL，其中包含恶意代码
    - 用户打开带有恶意代码的URL，**网站服务器**将恶意代码从URL中取出，拼接在URL中返回给浏览器
    - 用户浏览器接到响应后解析执行，混在其中的恶意代码也被执行
    - 同存储型最后一步
  - 适用范围：常用于通过URL传递参数的功能，如网站搜索、跳转等
  - 另：POST方式需要构造表单并诱导用户点击 ？？？？
- DOM-XSS
  - 恶意代码也在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的 URL，其中包含恶意代码。
    - 用户打开带有恶意代码的 URL。
    - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
  - 取出和执行恶意代码完全由 浏览器端完成，为Javascript前端的安全漏洞

##### 预防

- DOM型：
  - 使用 `.textContext` 和 `.setAttribute` 来替代 `.innerHTML`、`.outerHTML`、`document.write()`
  - 技术栈，react，少使用 dangerouslySetInnerHTML
  - 注意那些可以把字符串当做代码运行的部分：
    - DOM中的内联事件监听器：location、onclick、onerror、onload、onmouseover 等
    - <a 标签的 href 属性
    - javascript 代码 setInterval、setTimeout
- 跟服务端相关的两种类型
  - 选取合适的 HTML转义库
  - 注意拼接HTML的操作，尽量使用createElement等行为来生成 dom元素
  - 纯前端渲染？？
    - 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
    - 然后浏览器执行 HTML 中的 JavaScript。
    - JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

#### CSRF攻击

https://www.tuicool.com/articles/7Ff2EbZ

跨站请求伪造，在访问黑客网站时的操作会被操作到其他网站上

- 利用 img、script、iframe 的src标签可以请求跨域资源的特性，通过这些src来请求一些不规范的get请求（本应该是修改数据的post请求但是可能由于安全疏忽写成了get请求）
- post请求处理关键业务，利用 界面原生 form 表单可以跨域提交的特性，再加上空白iframe实现无刷新，可以再用户不知情的前提下实现跨域发送伪造请求

解决办法：

- 验证码

- 可以使用csrf-token的方式，服务端生成csrf-token，并通过服务端渲染的方式，将其设置到隐藏 form表单中 发送给用户，用户每次提交post请求时都会自动添加这个form表单中的csrf-token，服务端通过验证token即可得知当前请求是不是原站发过来的真实请求

## CDN



# typescript

继承和实现的区别

https://juejin.im/entry/5981c5df518825359a2b9476

# HTML5

## 离线存储

### manifest

我们知道浏览器是可以自动缓存访问过的 html、js（内存）和css（硬盘）文件的，manifest的意义在于就算我们不请求某些文件，浏览器也可以对这些文件进行缓存

应用程序缓存机制，使得基于Web 的 应用程序可以离线访问 Application Cache（.appCache）

- 离线浏览：用户可以在离线状态下浏览网络内容
- 快速响应：数据存储在本地，所以速度更快
- 减轻服务器的负载：浏览器只会下载在服务器上发生改变的资源

`<html manifest='example.appcache'>`

所有在html上制定了 manifest 的html文件，都是默认离线存储的，这些文件不需要写到 appcache 中

manifest特性指定的是一个 **缓存清单** 文件，在加载文档时，

- 如果应用缓存存在，浏览器直接从缓存中获取文件资源，不会访问网络
- 浏览器检查清单文件中列出的资源是否在服务器上被修改过
- 如果清单被更新了，浏览器会下载新的清单文件和相关资源

manifest文件的段落

- CACHE（默认段落）：其中列出的文件会在它们第一次下载完毕之后缓存起来
- NETWORK：需要与服务器保留连接的白名单，所有类似资源的请求都会绕过缓存
- FALLBACK：后备页面，当资源无法访问时，浏览器会使用这个页面

### IndexedDB

IndexedDB：浏览器提供的本地数据库，可以被网页脚本创建和操作（属于NoSQL数据库，不支持SQL查询语句）

http://www.ruanyifeng.com/blog/2018/07/indexeddb.html

应用场景：前端缓存

1. 键值对存储：对象仓库，所有类型的数据都可以直接存入。对象仓库中，数据以“键值对”的格式保存，每条数据都有一个独一无二的主键
2. 异步：indexedDB操作时不会锁死浏览器，用户依然可以进行其他操作。LocalStorage的操作是同步的
3. 支持事务：一系列相关操作中，只要有一步失败，整个事务就被取消，数据库回滚到之前的状态，不存在只改写一部分数据的情况
4. 同源限制：网页只能访问自身域名下的数据库
5. 储存空间：>=250MB
6. 支持二进制存储：ArrayBuffer对象和 Blob 对象



### File API

`<input type='file' onChange={} />`

可以通过onChange事件监听 用户选择文件的操作，用户选择的文件列表在 这个input控件 的files 属性上

input.files 由多个 File对象组成，File 对象继承自 Blob 对象，同时拥有自己的属性，如name、size、type、lastModified 等（Blob：Binary Large Object，代表一段二进制数据）

#### FileReader API

用于读取文件，把文件内容读入内存，其参数为 File 对象或 Blob 对象

- readAsText(Blobl | File, opt_encoding)：以一定的编码方式读取文件，返回文本字符串
- readAsDataURL(Blob | File)：返回一个基于base-64 编码的 data-uri 对象
- readAsArrayBuffer(Blob | File)：返回一个ArrayBuffer对象

FileReader采用异步方式读取文件，可以指定一些异步函数

onabort、onerror、onload、onloadend（不管成功还是失败都会调用这个方法）、onloadstart（读取即将开始之前）、onprogress（读取过程中周期性触发，可以用来获取文件读取的进度）

#### URL对象

`var objectUrl = window.URL.createObjectURL(blob | File)` 

传入一个File对象或Blob 对象，生成一个可以访问的url地址，这个url的存在期等同于网页存在的时间，一旦网页刷新或卸载，这个URL就会失效

【注】即使是同一个文件，同样的 二进制数据，生成的url也是不同的

可以用来做图片预览

## 性能/集成

### history API

HTML5 之前的history API 提供了 history.go(x)（跳转到）、history.back()（后退一步）、history.forward()（前进一步）的操作来操作界面记录

HTML5中添加了对历史记录中条目的修改和添加的方法

- history.pushState(stateObj, title, url) ：添加一条历史记录，不刷新页面

  title目前被忽略，stateObj为该url对应的state对象，url可以为绝对路径或相对路径（相对于当前文件的路径）

- history.replaceState(stateObj, title, url)：替换当前的历史记录，不刷新页面

- window.popstate：历史记录发生改变时触发，pushState和replaceState时不会触发

- window.hashchange：当页面的hash值改变时触发

在pushState和 replaceState 时，浏览器根本不会去检查我们要跳转到的这个页面是否存在，也不会真正实现跳转，只会更新url地址栏

【应用】react-router中history部分的实现就是根据这个机制实现的，但是由于 pushState 和 replaceState 不会触发页面更新，react-router中的Route组件在每次pushState之后都会setState来触发对应component的更新

### 拖放API

一个元素如果想要使用拖放API的话需要声明 `<p id='1' draggable='true' ondragstart='xxx'>xxx</p>`  也即需要声明 draggable 为true

放置区：`<p id='2' ondrop='xxx' ondragover='xxx'>drop area</p>`  ondragover和 ondrop 事件 让一个元素变成可放置区域

拖放结束：源元素上触发 `dragend` 事件（不管是拖动完成 还是 取消都会触发这个事件，可以通过在 ondrop时设置的 dropEffect 属性的值来确认）

### requestAnimationFrame

更新动画的一个方法，参数为一个callback，可以在浏览器屏幕每次刷新时调用这个callback，保证动画的流畅性；同时，当requestAnimationFrame运行在后台标签或隐藏的`<iframe>` 中时，这个方法会被暂停调用

## 通信

### Web Socket

### WebRTC

## 绘图

### Canvas

平面绘图

### WebGL

3D绘图

# Javascript

https://github.com/mqyqingfeng/Blog

## 基础

### for in 和 for of

for in：更适合纯对象的遍历，也可以对类数组（nodelist、arguments）进行遍历（类数组：可以通过索引访问元素，并且拥有length元素，但是没有数组的其他方法，如 push  forEach  indexOf等），在遍历数组时遍历的是下标值，如果需要知道下标的话使用for in 比较合适

for of：更适合不需要知道下标值时的数组遍历，无法遍历对象，可以遍历类数组对象

如果是遍历数组的话，需要知道下标时一般使用forEach，但是 forEach 不能在循环中直接break 或 return false，而不需要知道下标时可以用 for...of

关于 == 和 加法运算符，可见 掘金思考题整理md

### 变量对象（VO）和活动对象（AO）

VO和AO只是同一个对象在执行上下文不同阶段下的表现方式，VO在创建阶段，AO在执行阶段

例子：

```javascript
console.log(foo) // 打印函数
function foo() {
    console.log("foo")
}
var foo = 1
/**
* VO = { foo: function foo{} }
* console.log执行的时候，AO中的foo还是函数，而没有被赋值为 1，所以输出函数
*/

var foo = 1
console.log(foo) // 1
function foo() {
    console.log("foo")
}
```



这段代码，我默认是全局环境下执行。
执行上下文的生命周期可以分为两个阶段(也就是这段代码从开始到结束经历的过程)。

- **创建阶段**
  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向
- **代码执行阶段**
  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。执行阶段的VO会变成AO

**这里我们先重点了解执行上下文中变量对象的创建。**

变量对象的创建，依次经历了以下几个过程。

1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值(全局环境下没有这步)。
2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。**如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。**
3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。**如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。**(上面的例子就属于这种情况，foo函数名与变量foo同名)

**在上面的规则中我们看出，function声明会比var声明优先级更高一点。**

我们直接从全局执行上下文开始理解。全局作用域中运行时，全局执行上下文开始创建。为了便于理解，我们用如下的形式来表示。

```javascript
创建过程
global:EC = {
    // 变量对象
    VO: {},
    scopeChain: {},
    this: {}
}

// 因为暂时不详细解释作用域链和this，所以把变量对象专门提出来说明

// VO 为 Variable Object的缩写，即变量对象
VO = {
    foo: <foo reference>  // 表示foo的地址引用
   // foo: undefined
(如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。这个过程已被忽略)
}
```

未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。

需要注意的是，在VO转换为AO的过程中是有顺序效应的，如果console.log的时候，foo还没有被赋值为1，那么它的值还是保留之前的函数，所以在上例中的第一个例子中，输出的是函数，而第二个是1

```javascript
// 执行阶段
VO ->  AO   // Active Object
AO = {
    foo: 1(此时函数已被重新赋值)
}
```

因此，上面你提供的代码，执行顺序就变成了这样：

```javascript
function foo(){
	console.log("foo");
};
foo = 1;
console.log(foo);
```

所以最后打印的是1.



#### 另一种理解

楼主，关于词法解析阶段的初始化顺序，你的总结和我之前的了解有很大出入啊，第一阶段是分析形参没疑问，但是是第二阶段你总结的是分析函数声明，我的笔记第二阶段是分析var声明的变量，最后一个阶段才是函数声明。笔记如下：

词法分析：

1. 分析形参：接收形参到挂载到AO，接收实参赋值，如果没有传实参，值为undefined
2. 分析变量声明（var）：如果AO上已存在，不做修改（var 声明的变量和参数本质上都是私有变量），如果AO上不存在，挂载到AO,值undefined。
3. 分析函数声明：挂载函数名到AO，并赋值函数体， 如果AO上已存在，覆盖。

注：

函数声明，在词法分析阶段，函数名挂载到AO上时，就在这个阶段立马赋值。
var 声明的变量，词法解析阶段，只负责挂载该变量到AO上，值为undefined，赋值在执行阶段进行。
也就是说在执行阶段赋值的，只剩下var声明的变量。
即使是使用var声明的函数表达式这种情况，在AO上值也为undefined。

用这个顺序解释任何场景的题目感觉都挺合理的，特别是对于变量重名的时候，例1：

```javascript
console.log(a);//function(){}
var a = 1;
function a() {};
console.log(a);//1
```

词法分析顺序：形参->var声明->函数声明（包括赋值）

词法分析阶段结束时（未进入执行阶段），因为函数声明是最后分析的，所以AO:{a:function(){}}。
然后进入执行阶段，遇到console.log(a)，此时AO上a为function(){},所以打印函数，继续向下执行，遇到var a = 1; 因为是执行阶段，只执行 a = 1,所以AO{a:1}。继续向下执行，遇到console.log(a);，打印此时AO上a，也就是1。

例2（上面大家的例子）：

```javascript
console.log(foo);//function(){}
function foo(){
     console.log("foo");//没执行
}
var foo = 1;
```

词法分析顺序：形参->var声明->函数声明（包括赋值）

词法阶段结束后（未进入执行阶段），AO{foo:function(){}}
然后是执行阶段，遇到console.log(foo)，此时AO上的foo就是函数体，所以打印函数，然后继续执行，遇到var foo = 1;执行foo = 1;此时AO{foo:1}，执行完毕，AO上最终的foo为1。但是你在代码最上面打印foo的时候，var foo = 1;这一句还没执行，AO上的foo还是函数，未被1覆盖。如果在代码的最后再打印一次console.log(foo)，那就是1了。

至于你们上面总结的：
1，同一作用域下,函数提升比变量提升得更靠前。
2，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。
【这些都是主观的结论，优先级之分只是表象，根本原因还是词法分析顺序和执行顺序一起决定了谁覆盖了谁】

### this 的另一种理解

https://github.com/mqyqingfeng/Blog/issues/7

### Object

Object.getOwnPropertyNames 和 Object.keys() 都是用来获取对象属性名称的方法，区别在于：

- getOwnPropertyNames：只能获取该**对象实例**属性的属性名称，（但是包括所有的 **可枚举属性 和 不可枚举属性**）
- Object.keys：可以获取**对象实例**属性的属性名称，但是只限于**可枚举属性**
- for-in循环：返回所有通过对象可以访问的（**对象实例 或 原型链**）、**可枚举**的属性

### Array

只用 `new Array(3)` 直接声明的arr 变量，是一个稀疏数组，虽然在chrome 下输出为 [empty * 3]，但是它跟普通的 undefined 有所区别，主要是因为 这种情况声明的数组，只有length属性，在各位置上其实是没有填充值的，也就是说，这个数组对象 并没有 0 这个key，所以对于那些**在操作之前需要检查 Array对象是否有 index key（这个操作在ECMAScript2015中叫做 HasProperty(O, key)** 的操作，仅有它是不会进行真正的遍历的，这些操作主要包括：

https://www.zhihu.com/question/60919509

- for...in
- copyWithin(target, from, to) : 将 from-to 位置的元素copy 到 target开始的位置上去，如果from-to 中有empty的话，会删掉对应的target位置的元素为empty
- every
- filter
- forEach
- indexOf 的时候会跳过 HasProperty(O, key) 为false 的值
- lastIndexOf 同理
- map
- reduce
- reduceRight
- sort 的时候会把 empty的元素放到最后
- unshift(...items) 的时候会把插入的empty元素转换为 undefined

可以通过查看ECMAScript 来验证 http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.map

### Date

Date.parse(str)：返回一个从**1970-01-01** 到 传入str的日期对象的毫秒数（如果传入日期比1970-01-01小，那么返回一个负数）

## es6

### class

如果父类有方法不想让子类继承，需要怎么做

#### class 是 Function 的语法糖，那么class 和 function有哪些区别

1. class 内部只能有 构造函数constructor、方法、存值取值函数（get\set）、属性表达式（\[:expression]()）

2. class 只能用new 来声明，不能直接按照普通函数调用那样使用

3. class内部自动声明为严格模式

4. class类不存在变量提升（方便“继承”的使用）

5. 类 相当于 实例的原型，所有在类中定义的方法，都会被实例继承

6. 可以定义**静态方法**，static 关键字——该方法只能直接通过类来进行调用（**静态方法中的this 指的是 这个class（即实例原型），而不是实例**

   静态方法可以被继承

7. **静态属性**，定义在 class 上，而不是实例上的属性 ( 只能在class外部定义Class.prop = 1 )

### promise

promise的then：

promise1.then 每次都会返回一个新的Promise对象，如果这个then的 onFulfilled 的返回值为一个 Promise对象 p2，那么会调用p2.then ，并将其返回值作为 promise1 的返回值（会一直递归到这个onFulfilled函数不是Promise对象为止，那么这次 pn 返回值为一个 new Promise 对象），因此，不管什么时候调用 多次 Promise.then，然后比较这几个返回值是否相同时，他们都是不同的，因为指向的都是不同的Promise对象



promise 的then函数中是如何获取上次resolve的值的？

promise 内部会存储一个value值，用于存储当前resolve传入的参数值



同一个promise对象a，多次执行a.then 会有什么反应？

多个a.then 都会执行，如果在执行then的时候这个Promise的状态已经变成 fulfill了，那么就直接执行对应的then方法，如果执行then的时候 Promise 的状态仍然是 pending，那么会內建一个 callbacklist，存储对应的 resolve 和 reject ，并在这个promise resolve的时候串行执行这些 resolve（或reject）



promise中如果有未被处理的error，会有什么表现？

会中断Promise链的执行，但是不会影响promise之外其他代码的执行，会在promise内部抛出一个错误

### async/await

await 具体作用是什么

## es7



## webpack

介绍、loader

## 跨域

https://harttle.land/2015/10/10/cross-origin.html#header-5

同源策略：协议、域名、端口都相同，才可以

- 读取 Cookie、localStorage、indexDB
- 获取DOM 和 JS 对象
- 发送AJAX请求

问题：为什么`<iframe> \ <img> \ <script>` 等设置src属性的标签都可以跨域访问，而XMLHttpRequest 或 fetch 是不能通过浏览器的跨域检查的呢

https://www.yinchengli.com/2016/09/16/cross-domain/

- 问题点一：读请求都是会发送出去的，比如GET或 预检请求 OPTIONS，浏览器不会限制 XHR 和 fetch发送这种请求，但是如果服务器返回不允许跨域的话，浏览器会阻止信息返回，也就是说，服务器是正常返回数据的，只是数据被浏览器劫持了（浏览器不限制写？？？为什么）
- 问题点二：通过src 属性加载的内容，浏览器限制了我们无法通过 js 读写这个src返回的内容，而 XHR 和 fetch 读取的内容都是可以被 javascript 操作的，所以需要对其进行同源的限制

解决跨域问题的几种方法

1. jsonp：只能发送get请求

   原理：浏览器允许将js、css、img等静态资源分离到另一台独立域名的服务器上，通过这个与当前域名不同的服务器来加载静态资源

   动态创建script，请求一个带参网址来实现通信

   缺点：只能发送get一种请求

2. document.domain + iframe ： 主域相同，子域不同的情况

   - 原理：两个页面通过js设置document.domain为同一主域从而实现同域（仅限于两个页面主域相同，子域不同的情况）
   - 只能获取不同域的 dom 和 js 对象

3. location.hash + iframe

   - 不同域的iframe只能，父窗口设置子窗口的hash值，子窗口不能获取父窗口 js 相关信息
   - 实现方式：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

4. window.name + iframe

   - 原理：name值在不同的域名加载后仍然存在，只要浏览器标签页不关闭，name值就不变

   - 实现方式：可以在window.name中记录想要跨域传输的信息

     - 当请求不同域的信息时，在该被请求文件中设置 window.name  值为想要传递的信息，在当前页面中创建一个iframe，src设置为该被请求文件路径，iframe onload的时候，这个window.name 已经被设置了，之后再将iframe 的src设置为与当前文件同域名的一个空文件，这时会再次出发iframe 的 onload 事件，我们可以用一个状态位来记录当前已经把域名设置为同域了，可以读取其中的window.name值，从而实现js的通信

     ```javascript
     <script type=”text/javascript”>
     //背弹广告
     var iframeDate;
     var state = 0,//开关变量
     iframe = document_createElement_x_x(‘iframe’),//创建iframe
     loadfn = function() {
     	if (state === 1) {
     		iframeDate = iframe.contentWindow.name; // 读取数据
      		if (iframeDate > 0) {
     			alert(“获取到了iframe出过来的值”);
     		}
         } else if (state === 0) {
     		state = 1;
      		iframe.contentWindow.location = “http://www.a.com/other.html”; // 设置的代理文件,当走到这一步时,由于iframe的location改变了,导致重新执行 loadfn 方法(红色部分) 这时开关变量 state已经变为1 所以轻松获取window.name 的值.
     	}
     };
     iframe.src = ‘http://www.b.com/ifram.aspx?nid=1000′;
     if (iframe.attachEvent) {
     	iframe.attachEvent(‘onload’, loadfn);
     } else {
     	iframe.onload = loadfn;
     }
     document.body.a(iframe);
     </script>
     ```

     

5. html5 postMessage

   https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage

   - 用于解决以下问题
     - 页面和其打开的新窗口之间的消息传输
     - 多窗口之间消息传递
     - 页面与嵌套的iframe消息传递

## 原理

### instanceof 原型链

instanceof的原理就是，a.__proto\_\_ = A.prototype，那么 a instanceof A 就是正确的，而且只要可以在这个原型链上继续往上翻，instanceof 都会返回true

https://alexzhong22c.github.io/2017/08/08/js-proto/

实例对象 f 的\__proto__指向原型对象 Foo.prototype，Foo.prototype.constructor 指向构造函数 Foo，由原型链：f.constructor 指向构造函数 Foo

实例对向 obj 的\__proto__ 指向原型对象 Object.prototype, Object.prototype.constructor 指向构造函数 Object，有原型链：obj.constructor 指向构造函数 Object

![1554775214835](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554775214835.png)

1. 构造函数Foo 作为实例对象：每个函数都可以看作是 new Function(xxx)构建的对象

   Foo.\__proto__ = Function.prototype，Function.prototype.constructor = Function 

   => Foo.constructor = Function

2. 原型对象Foo.prototype 作为实例对象：每个对象都可以看作是 new Object() 构建的对象

   Foo.prototype.\__proto__ = Object.prototype,  Object.prototype.constructor = Object

   => Foo.prototype.constructor = **Foo** 因为在Foo.prototype自己内部找到了constructor属性，不需要继承原型链上Object.prototype 的constructor属性

3. 构造函数Object作为实例对象：每个函数都可以看作是 new Function(xxx) 构建的对象

   Object.\__proto__ = Function.prototype,  Function.prototype.constructor = Function

    => Object.constructor = **Function**

4. 原型对象Object.prototype作为实例对象：Object.prototype.\__proto__ = null

5. 构造函数Function作为实例对象：每个函数都可以看作是 new Function(xxx) 创建的对象

   Function.\__proto__ = Function.prototype

6. 原型对象Function.prototype 作为实例对象：每个对象都可以看作是 new Object(xxx) 创建的对象

   Function.prototype.\__proto__ = Object.prototypes

Array的prototype是否可以修改：不可以，所有js内置的构造函数的prototype都不能改

typeof Function.prototype 值为 “ function ”：也就是说，Function.prototype是一个特殊的对象

### 创建对象

#### 使用原型模式创建对象

```javascript
function Person() {
    
}
Person.prototype = {
    constructor: Person, // Person.prototype中的constructor指向Person构造函数
    name: 'zwq',
    age: 24,
    job: 'student',
    sayName: function() {
        console.log('hello')
    }
}
```

以上代码中有一个缺点是：用户自定义的对象属性，默认enumerable属性为true，也就是说 constructor会变成可遍历属性（for...in 和 Object.keys() 都会拿到这个属性），这与其默认行为是不符的，所以使用

```javascript
Object.defineProperty(Person.prototype, 'constructor', {
    value: Person,
    enumerable: false
}) // 用这个定义方法来替代Person.prototype中直接定义constructor属性的方法
```



可以在声明实例变量之后修改其原型对象的一些属性，但是如果是用Person.prototype = {}来对它的原型对象进行重写，那么原先声明的实例变量只能取到旧的原型对象的属性，新原型对象的属性是取不到的

```javascript
function Person(){}
const p1 = new Person()
Person.prototype.sayName = function() {
    console.log('hello')
}

p1.sayName(); // hello
Person.prototype = {
    name: 'zwq',
    callName: function() {
        console.log(this.name)
    }
}
p1.callName() // error
```

也就是说，使用重新赋值的方式会切断原先声明的变量和Person.prototype 之间的联系，旧的变量引用的还是旧的prototype



原型模式的关键在于：**共享**，在prototype上定义的引用类型的变量都是共享的，对于函数来说它可以节省开销，但是对于Array、Object这样的引用类型变量作为原型value时，我们在一个实例变量中对它的Array进行操作（如push\pop\shift等会影响原数组的操作），那么另一个实例变量的对应属性由于指向同一个内存地址，会感应到这个变化，

通常我们在新实例化一个变量的时候是希望给它分配一个不被别人影响的内存空间，而不是和其他实例变量一起共享某些属性



#### 解决办法：混合使用原型模式和组合模式

就是把需要共享的属性放到Prototype里，而把不需要共享的属性放到Person自己的构造函数里

```javascript
function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype = {
    sayName: function() {
        console.log(this.name)
    }
}
Object.defineProperty(Person.prototype, 'constructor', {
    enumerable: false,
    value: Person,
})
```

#### 更加面向对象的对象创建模式：动态原型模式

```javascript
function Person(name, age) {
    this.name = name
    this.age = age
    if (typeof this.sayName !== 'function') {
        Person.prototype.sayName = function() { // 这里只能用这种方式定义，不能用对象字面量方式重写，因为重写之后会切断已存在实例对象和旧的原型对象之间的关系
            console.log(this.name)
        }
    }
}
```



### 继承

#### 经典继承

```javascript
function SuperType() { 
	this.color = ['red', 'blue', 'green']
}

function SubType() {
    // 继承关键代码
    SuperType.call(this)
}

var instance1 = new SubType()
instance1.colors.push('black')
console.log(instance1.colors); // red, blue, gree, black

var instance2 = new SubType()
console.log(instance2.colors); // red, blue, green
```

这个继承模式相当于把SuperType实例里的所有属性和方法都复制一份到SubType里

好处：每个SubType都拥有自己独有的一份空间，引用类型变量不会发生共享的问题

缺点：

1. 没有继承原型链上的属性和方法，无法使用instanceof 判断原型链
2. 可以共享的函数定义没有共享，而是创建了两个一模一样的函数

####  组合继承

原理：使用原型链实现对原型属性和方法的继承，使用构造函数实现对实例属性的继承

```javascript
function SuperType(name) {
    this.name = name
    this.colors = ['red', 'green', 'blue']
}

SuperType.prototype.sayName = function() {
    alert(this.name)
}

function SubType(name, age) {
    // 继承父构造函数的实例属性
	SuperType.call(this, name) // 第二次调用父构造函数
    this.age = age
}
// 继承父原型对象的属性和方法
SubType.prototype = new SuperType() // 第一次调用父构造函数
SubType.prototype.constructor = SubType

const child = new SubType(); 
```

优点：可以使用 instanceof / isPrototypeOf() 判断原型链上的对象属性，而且不会共享不想被共享的对象的和方法

缺点：父原型对象的构造函数会被调用两次，

- 第一次是在 构建原型链的时候，SubType的prototype（原型对象）上 创建了一个SuperType 实例，那么SubType.prototype 会有一个 name 和 colors 的属性，
- 而在初始化 child 对象时，new SubType 在SubType 的构造函数中 又调用了一次 SuperType的构造函数，在SubType对象上添加了一个name 和colors 的属性
- 

#### 原型继承

原理：借助原型基于已有的对象来创建新的对象

```javascript
function object(o) {
	var F = new Function(){}
    F.prototype = o
    return new F()
}
// 这段代码作用相当于
var B = object(A)
var B = Object.create(A, {
    name: {
        value: 'xxx'
    }
})
// Object.create 方法的第二个参数格式与 Object.defineProperties 相同
```

从本质上讲，object对传入的对象进行了一次浅复制

适用于简单考虑对象复制的继承

缺点：原型模式继承的对象始终共享引用类型的值

#### 寄生继承

原理：类似寄生构造函数和工厂模式，即创建一个用户封装继承过程的函数（依赖于原型继承实现继承）

```javascript
function createAnotherPerson(person) {
    var clone = object(person)
    clone.sayHi = function() {
        console.log('hi')
    }
    return clone
}
```

当主要考虑对象不是自定义类型和构造函数的情况下，寄生式继承是可以使用的

缺点：

1. 原对象person 的引用类型被所有继承对象所共享
2. 当需要为继承对象添加多个函数时，继承对象实例不能共享函数，效率较低

#### 寄生组合式继承

组合式继承的缺陷：父类的构造函数被执行了两遍，给SubType.prototype 和 subType实例对象都添加了对应的属性，但是其实只有一个就可以了

寄生式继承的缺陷：父类的引用类型属性被所有继承对象共享，改一个就相当于改了全部；而且为继承对象添加函数时函数无法共享

寄生组合式继承：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法

基本思路：不必为了指定子类型的原型而调用超类的构造函数，我们只是想要一个超类原型对象的副本，本质上就是使用寄生式继承来继承超类的原型，然后再将结果指定给子类型

```javascript
function inheritPrototype(subType, superType) {
    var prototype = Object.create(superType.prototype) // 创建对象
   	prototype.constructor = subType // 增强对象
    subType.prototype = prototype // 指定对象
}
// 使用这种方式实现的继承，不会再构造继承链的时候调用超类的构造函数，也就是说不会再subType.prototype 对象上添加超类的构造函数中的属性
// 调用方式
function SuperType(name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function() {
    console.log(this.name)
}

function SubType(name, age) {
	SuperType.call(this, name)  // 调用超类的构造函数，在子类的实例对象上添加它应该持有的自己的非共享属性和方法
    this.age = age
}

inheritPrototype(SubType, SuperType) // 这里不会调用超类的构造函数

```

优点：

1. 只调用了一次SuperType 构造函数，并且避免了在SubType.prototype 上创建不必要的属性

2. 保持原型链不变

### 块级作用域

const一个函数，能否修改这个函数的this？

答：函数this的指向，如果没有绑定，在调用的时候确定，但是也可以对它进行this指向的修改（如bind等操作，这个时候会返回一个新的函数放到堆内存里，对原函数没有影响），和const无关

## 具体问题

### 函数防抖和节流

https://zhuanlan.zhihu.com/p/38313717

### 大数相加（包含负数）

### 实现一个简单的Promise

### 数组去重，里面有对象，数组

### 深拷贝的两种方法

（对象、数组、函数

### 实现reduce

### 金额加逗号



# 算法

https://github.com/azl397985856/leetcode

https://www.qiujiawei.com/tag/leetcode/

## 排序

https://www.cnblogs.com/onepixel/articles/7674659.html

### 快排

### 冒泡



## 动态规划

https://www.zhihu.com/question/23995189/answer/613096905

如何找到两个数组的最长相同子序列

### 其他问题

抽牌算法

# css

如何用css实现一个左右两栏高度与中间块高度同高的布局

### 布局

flex、grid、position、float

#### 重排和重绘

https://juejin.im/post/5a9372895188257a6b06132e

哪些操作会触发重排（reflow）：

- **盒模型**相关属性：width、height、margin、display、border
- **定位属性及浮动**相关属性：position、float、top
- **改变节点内部文字结构**：text-align、overflow、font-size、vertical-align、line-height
- 调整窗口大小
- style变动
- **元素内容**变化（尤其是输入控件）
- dom操作
- **css伪类**
- 计算元素的offsetHeight、offsetWidth、clientWidth、clientHeight、width、height、scrollHeight、scrollWidth

#### 绝对定位和相对定位的区别

## 动画

### transition 和 animation 的区别

animation可以定义多个关键帧（关键帧：也就是这个animation动画过程中的各个阶段 from（0%），to（100%），中间各个百分比阶段都可以定义该元素的属性）；transition就像是只有两个关键帧的animation

animation可以设置`animation-iteration-count: infinite` 来定义动画无限循环，也可以通过设置 `animation-direction: alternate` 来让动画来回运动；transition无法循环



animation中有 AnimationEvent的事件

- animationstart
- animationend
- animationiteration

我们需要在为对应元素注册好对应的事件监听之后再启动该元素的animation动画（比如在添加监听之后再为元素添加 动画对应的class 类名

可以查看这个CodePen示例：https://codepen.io/pen/?&editable=true



除以上css实现动画的方法外，也可以是用 js中的 setTimeout 或 HTML5 中的requestAnimationFrame 来进行设置

# 前端大类问题

## 函数式编程

含义：

1. 不改变原对象
2. 生成新对象
3. 输出完全依赖于输入，无副作用

意义：可跟踪、可测试、可观察（shouldComponentUpdate很好写）

## 浏览器从输入URL到页面展示发生了哪些过程

## 浏览器进程与线程的关系

这篇文章将的很好，从浏览器进程 -> 浏览器内核（渲染进程）中的线程 -> 浏览器渲染过程 -> js事件循环，看它！！https://segmentfault.com/a/1190000012925872

### 浏览器进程

知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）

1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
   - 负责浏览器界面显示，与用户交互。如前进，后退等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
   - 网络资源的管理，下载等
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程：最多一个，用于3D绘制等
4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为
   - 页面渲染，脚本执行，事件处理等

强化记忆：**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**

### 浏览器内核（渲染进程）中的线程

**请牢记，浏览器的渲染进程是多线程的**（这点如果不理解，**请回头看进程和线程的区分**）

终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：

1. GUI渲染线程
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
   - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
2. JS引擎线程
   - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
   - JS引擎线程负责解析Javascript脚本，运行代码。
   - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
   - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. 事件触发线程
   - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
   - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时触发器线程
   - 传说中的`setInterval`与`setTimeout`所在线程
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 异步http请求线程
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。

### EventLoop js的运行机制

https://juejin.im/post/6844903968292749319

## 垃圾收集

https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-7

新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。

老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。

## 浏览器缓存

https://juejin.im/entry/5ad86c16f265da505a77dca4

有两个位置存储缓存

1. 内存缓存：速度更快，存储的内容较少
   - 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下一次运行使用时的快速读取
   - 时效性：一旦该进程关闭，则该进程的内存则会清空
2. 硬盘缓存：直接将缓存写入硬盘文件中，速度较慢，需要I/O操作读取文件，然后重新解析该缓存文件

浏览器通常将 js 和 html 存入 内存缓存， css 存入硬盘缓存

## 进程和线程的区别

单个CPU一次只能运行一个进程，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。

一个进程可以包括多个线程，一个进程的内存空间是共享的，每个线程都可以使用这些共享内存

互斥锁：一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存，用来防止多个线程同时读写某一内存区域

信号量：某些内存区域可以给固定数目的线程使用，保证多个线程不会互相冲突

总结：

1. 多进程形式，允许多个任务同时进行
2. 多线程形式，允许单个任务分成不同的部分进行
3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，一方面允许进程之间和线程之间共享资源

# react

一些源码

https://github.com/KieSun/react-interpretation

react 在 render 的时候就是在构建虚拟dom树，所以其实每次都是在render结束之后才开始diff比对的

### diff的过程（为什么还需要shouldComponentUpdate）

- renderTree同层比较
- 三种操作：Add、Remove、Move（通过key对比实现）

为什么还需要 shouldComponentUpdate？

因为js diff运算也是耗费资源和时间的，如果可以根据prop或者state判断不需要修改，可以省下 diff运算的资源耗费

### react connect 和 Provider的作用是什么

### react页面切换动画怎么做

### PureComponent 和 普通组件的区别是什么

### setState异步更新 

在React中，**如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state**。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。

在React的setState函数实现中，会根据一个变量**isBatchingUpdates**判断是直接更新this.state还是放到队列中回头再说，而***isBatchingUpdates***默认是false，也就表示setState会同步更新this.state，但是，有一个函数**batchedUpdates**，这个函数会把***isBatchingUpdates***修改为true，而当React在调用事件处理函数之前就会调用这个**batchedUpdates**，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。

### react生命周期

#### 15版本

![img](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageslim)

#### 16版本



- constructor：初始化state、给实例绑定 事件处理函数
  - constructor中不应该调用 setState
- **static** getDerivedStateFromProps(nextProps, prevState)
  - 在 render 之前被调用
  - 在prevState中存储想要获取的prevProp，用来跟nextProp比对
  - 返回值为更新之后的state（整个替换）
  - **只能执行纯函数操作**：输出完全依赖于输入，不能执行副作用过程
- shouldComponentUpdate(nextProps, nextState)
  - 接收到新的state或props时调用，默认返回true
  - 首次render和forceUpdate()过程不会调用这个生命周期函数
  - return false 只能阻止当前组件重新render，不能阻止子孙组件重新render
  - 如果是为了“阻塞”某次更新的话，应该考虑使用 PureComponent，它会对props和state做一次浅比较
- getSnapshotBeforeUpdate(prevProps, prevState)
  - 最近一次render的结果要被提交给dom之前调用，可以在DOM更新前获取一些信息
  - 返回值会被当作第三个参数传递给 componentDidUpdate
  - 需要返回null或一个默认值
- componentDidMount
  - 发送请求获取数据
  - 注册事件（需要在unmount中取消事件）
  - 在这里**立即**调用setState时，render会被调用两次，但真正实际的dom更新只有一次？？？
- componentDidUpdate(prevProps)
  - 更新完成后操作DOM节点
  - 对比props之后可以发送请求获取数据
- componentWillUnmount



#### 为什么说 componentWillUpdate 和 componentWillReceiveProps 会被调用多次，而componentDidUpdate 只会被调用一次

react 16 Fiber架构，两个阶段

- reconcile阶段：可以被打断
  - prop/state更新->生命周期函数 -> 虚拟dom -> diff -> 修改真实dom
  - 可能被调用的生命周期函数：
    - componentWillMount
    - componentWillUpdate
    - componentWillReceiveProps
    - shouldComponentUpdate
- commit阶段：不可以被打断
  - 可能被调用的生命周期函数
    - componentDidUpdate
    - componentDidMount
    - componentWillUnmount

Fiber 是比 thread 更细的粒度，js是单线程的，fiber就是让react在reconcilation阶段，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务需要更新

- 有的话，做紧急任务，当前分片的更新过程作废
- 没有的话继续执行下一个分片的更新任务

### key的作用

## redux

https://tech.meituan.com/2017/07/14/redux-design-code.html（这篇技术文章总结的很好，下面记录几个关键点）

![1555756304747](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1555756304747.png)

store 不是一个简单的 object 对象，它是应用全局state、dispatch、subscribe方法等一系列东西的组合

调用流程：

1. 用户通过view发出action，调用了 dispatch 的方法
2. store 自动调用 reducer，传入两个参数：当前state和 触发的action，reducer 返回一个新的state
3. state有变化，store会调用监听函数，通知view 进行更新

redux 的**设计理念**：**让每个 state 变化都是可预测的，将应用中所有的动作和状态都统一管理，让一切有据可循**

**单向数据流**：UI 跟 数据和逻辑 分离，UI只负责渲染，而业务逻辑交给其他部分处理。单向数据流确保流程更加清晰

以下代码解读也可以结合上面的参考文章和 自己的redux 源码解读目录进行理解

#### createStore

生成Store

##### getState、replaceReducer

getState：获取当前state对象

replaceReducer：替换当前reducer并重新初始化 state树

##### subscribe：注册监听事件

注册监听事件，并返回取消监听的函数，把所有的订阅函数统一放到一个数组里，只维护这个数组

实时性：用两个数组来分别处理dispatch事件（currentListeners）和接收 subscribe事件（nextListeners）

- 入参函数放入监听队列
- 返回取消订阅的函数

##### dispatch：分发action，修改state的方法

- 调用Reducer，传入对应的state和action
- 按顺序执行listener
- 返回action

#### combineReducers：合并各部分reducer

传入一个 reducers组成的object对象，每个key对应的都是各部分reducer更新的function，在这里生成最终的reducer对象，并返回一个函数

返回的这个函数就是每次真正调用reducer的地方，在这里会传入的全局状态树state和action，内部逻辑就是遍历最后生成的 reducers 数组，对其中的每个reducer 和 对应部分的state 树，执行reducer（partState,action），并根据返回值的newPartState与旧的那部分的state进行全等比较，从而判断是否进行了更新（我们要求在reducer中default情况下应该返回原state对象），如果所有reducer都执行完毕之后发现 这个changed 标志位仍然为false，则说明这次没有更新，返回 旧的全局状态树

#### bindActionCreators：派发action的一个包装方法

接受两个参数，一个是actionCreatros列表（都是function，也就是return一个action的函数），一个是 Store 的diaptch 方法，把action creators转成拥有同名keys的对象，使用dispatch把每个action creator包装起来，这样可以直接调用它们（其实就是封装了dispatch，让外界对它无感）

#### compose：组合传入的函数

组合传入的一系列函数，中间件时会用到

```javascript
return funcs.reduce((a, b) => (...args) => a(b(...args)))
```

只有最后一个函数可以接受多个参数

#### applyMiddleware：store增强

在dispatch之前为 dispatch添加附加功能，返回 Store对象，并且用包装后的dispatch替代原来的dispatch

```javascript
export default function applyMiddleware(...middlewares) {
  return createStore => (...args) => {
    const store = createStore(...args)
    let dispatch = () => {
      throw new Error(
        'Dispatching while constructing your middleware is not allowed. ' +
          'Other middleware would not be applied to this dispatch.'
      )
    }

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) => dispatch(...args)
    }
    const chain = middlewares.map(middleware => middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch) // 这里的compose其实就是一系列的增强函数，dispatch是最终触发compose执行的参数
    // f(g(h(store.dispatch))) 相当于 next(g(h(store.dispatch)))
    // 因为我们需要返回一个可以替换原先dispatch 的函数，所以这个返回值其实也应该是一个可以接受 一个action作为参数 的函数
    // 只有在真正传入action 的时候，dispatch 才会被调用

    return {
      ...store,
      dispatch
    }
  }
}
```

由此的话我们可以推出中间件的写法：因为中间件是要多个首尾相连的，需要一层层的“加工”，所以要有个next方法来独立一层确保串联执行，另外dispatch增强后也是个dispatch方法，也要接收action参数，所以最后一层肯定是action。

```javascript
// redux-thunk 源码
function createThunkMiddleware(extraArgument) {
    return ({getState, dispatch}) => next => action => {
        if (typeof action === 'function') {
            return action(dispatch, getState, extraArgument)
        }
        return next(action)
    }
}
```

理解：传入action时真正触发 dispatch 执行，若action是一个函数，则调用这个函数并将增强后的dispatch传进去（由applimiddlerware源码可知，dispatch是函数内声明的一个自定义变量，而最后增强store.dispatch时我们又将dispatch重新赋值，所以这里在真正传入action执行的时候，dispatch是增强后的dispatch）

若action不是一个函数，则调用 next(action)，就是一层层调用 next，其实就是增强dispatch之后最后调用 store.dispatch

redux-thunk 的作用：普通的dispatch只能dispatch一个对象，redux-thunk可以让我们dispatch 一个函数，这个函数的参数是（dispatch, getState, payload），dispatch函数之后，我们就可以在这个函数里进行异步处理或调用接口

thunk 的含义就是 延迟执行，这里其实是延迟了真正的dispatch，只有在dispatch action 的时候才会触发reducer更新，所以这里实际上是延迟了 真正的reducer更新 

#### Q1：middleware为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？

因为中间件是要多个首尾相连的，对next进行一层层的“加工”，所以next必须独立一层。那么Store和action呢？Store的话，我们要在中间件顶层放上Store，因为我们要用Store的dispatch和getState两个方法。action的话，是因为我们封装了这么多层，其实就是为了作出更高级的dispatch方法，是dispatch，就得接受action这个参数。

函数柯里化，提前传入一些参数，构造好最后执行的函数，最后就可以只传入action进行调用了，也是对dispatch 的一个封装和增强

#### Q2：middlewareAPI中的dispatch为什么要用匿名函数包裹呢？

我们用applyMiddleware是为了改造dispatch的，所以applyMiddleware执行完后，dispatch是变化了的，而middlewareAPI是applyMiddleware执行中分发到各个middleware，所以必须用匿名函数包裹dispatch，这样只要dispatch更新了，middlewareAPI中的dispatch应用也会发生变化。

如果不包裹的话，传入middleware中的 dispatch 其实是增强前的dispatch 地址（结合函数按值传参的特性理解）可以同时查看源码中我的注释

#### Q3: 在middleware里调用dispatch跟调用next一样吗？

因为我们的dispatch是用匿名函数包裹，所以在中间件里执行dispatch跟其它地方没有任何差别，而执行next相当于调用下个中间件。



### 纯函数

1. 一个函数的返回结果只依赖于它的输入

2. 执行过程中没有副作用

   副作用：在执行过程中产生外部可观察的变化，如调用 DOM API 修改界面，或发送了ajax请求，window.reload，console.log

也就是说，纯函数限制我们基本只能计算数据，除此之外什么都不能干

好处：靠谱，不会产生不可预料的行为，也不会对外部产生影响，便于调试

**reducer**（执行store数据的更新）

每个reducer都是一个纯函数，在这个纯函数中需要返回一个新的 store 对象，但是这个store对象跟旧的store对象是共享某些变量的，没有被修改的部分就还是指向旧的变量（可以使用 扩展运算符或者 Object.assign 来实现 【注】这两个方法都是浅复制），这样的话，我们在对比新旧的state是否相同时，就不需要进行深层次的比较，只要比较根节点是否相同（也就是 newState === oldState）即可，而对于应用到state的不同part的对象而言（如 content 和 title），只要在其中对比 该部分的store是否相同，即可判断是否需要重新render当前节点

【注】单纯的reducer并不能对性能有什么优化，只有在组件中配合判断条件之后才会有性能上的提升

![img](https://huzidaha.github.io/static/assets/img/posts/4E4E9324-4659-4791-8957-137566C3A929.png)

dispatch：提高修改数据的门槛，必须通过dispatch才能执行一些允许被执行的修改操作，而且必须在 `action` 里声明被修改的部分

createStore：观察者模式，通过 store.subscribe 订阅数据修改事件，store 作为被观察者，各个更新store的方法作为观察者，当组件调用dispatch声明要进行数据更新时，dispatch就是触发更新的方法，这时会调用reducer更新 全局store，更新完成之后通知每个订阅者执行对应的回调方法（这个方法一般跟组件的渲染有一些关系，可能会在其中setState或者干嘛）

## react-redux

Provider:  在项目根组件中将 store 作为 context 注入

```javascript
export class Provider extends Component {
  static propTypes = {
    store: PropTypes.object,
    children: PropTypes.any
  }

  static childContextTypes = {
    store: PropTypes.object
  }

  getChildContext () {
    return {
      store: this.props.store
    }
  }

  render () {
    return (
      <div>{this.props.children}</div>
    )
  }
}
```

作用：

1. 渲染嵌套的内容
2. 把外界传给它的内容 `props.store` 放到context中，供子组件 connect 时使用

connect：一个高阶组件，接受参数为 (mapStateToProps, mapDispatchToProps) => (wrappedComponent)，包装wrappedComponent，在其中包装所有与context有关的操作，1. 获取context  2. 将该component关注的store对象（或者说是context对象）以prop的形式注入到 wrappedComponent中去，并提供一些在wrappedComponent中需要的，更新一些store的方法

```javascript
export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {
  class Connect extends Component {
    static contextTypes = {
      store: PropTypes.object
    }

    constructor () {
      super()
      this.state = {
        allProps: {}
      }
    }

    componentWillMount () {
      const { store } = this.context
      this._updateProps()
      store.subscribe(() => this._updateProps())
    }

    _updateProps () {
      const { store } = this.context
      let stateProps = mapStateToProps
        ? mapStateToProps(store.getState(), this.props)
        : {} // 防止 mapStateToProps 没有传入
      let dispatchProps = mapDispatchToProps
        ? mapDispatchToProps(store.dispatch, this.props)
        : {} // 防止 mapDispatchToProps 没有传入
      this.setState({
        allProps: {
          ...stateProps,
          ...dispatchProps,
          ...this.props
        }
      })
    }

    render () {
      return <WrappedComponent {...this.state.allProps} />
    }
  }
  return Connect
}
```



## react-router

http://kyriejoshua.github.io/jo.github.io/categories/React/  （这个是读源码比较 精细的一版，下文分析多参考这个文章）

刚开始的SPA有两个弊端：

1. 用户在使用的过程中，url不会发生改变，如果用户在使用过程中不小心刷新了页面，那么之前的操作记录就都没有了
2. 由于缺乏url，不利于搜索引擎收录

改变url的同时不刷新页面的方式有两种：

1. hash
2. history

react-router的包装闭环：

提供了一个history 库，history库会在createBrowserHistory 和 createHashHistory 时 返回一个接口一致的 history 对象，这两个类都是通过 transitionManager 这个类来实现 观察者模式的。

transitionManager中有一个listeners数组，并提供了几个方法，

- appendListener：添加观察者对象
- notifyListeners：通知观察者对象进行更新
- confirmTransitionTo：具体判断逻辑没有看懂，但是大概应该是加了一些逻辑来判断 传入的callback参数是否需要执行，需要执行的话返回 callback(true)，否则返回 callback(false)
- setPromptTo：设置Prompt？并且history在一个时间段只能有一个Prompt

 HashHistory 或者 BrowserHistory 内部都持有一个 transitionManager的引用，

- 当它们的push、replace方法被触发时，会根据浏览器支持情况去调用transitionManager的confirmTransition，回调函数为刷新页面（这里有一个很重要的地方是，因为history pushState 和 replaceState 是不会刷新页面的，所以history库在这里判断如果不需要强制刷新的话，会调用自己的setState，去通知所有的观察者执行更新方法）
- 提供listen方法，在 listen 方法中将传入的 listner 观察者添加到 transition 的listeners列表中，同时在DOM上注册 popstate 和 hashchange 的监听，对应的回调函数为handlePop，这里会在pop之后去更新listeners的数组，并添加了pop失败的revert函数，listen方法的返回值是对应的解绑函数

在react-router中

- Router：

  - 生成 history作为context下传

  - componentWillMount：注册了history.listen，注册了一个setState的事件
  - componentWillUnmount：unlisten解绑

- Route：依照 matchPath 方法，根据传入的真实路径 location || context.router.route.pathname，以及Route组件定义的 想要匹配的 path 路径，判断两个路径是否匹配（此处需要查看是否有exact，如果没有的话只要 pathname.indexOf(path) == 0 即可），如果匹配的话，再去执行 createElement（component）或 执行定义的 render 方法
- 触发回调的方式：
  - Link 最终表现形式为一个 a标签，在link 组件中，是阻止了 a 标签的默认行为，然后 根据prop 的 replace 和 to ，调用了history 的replace(to) 和 push(to) 的方法，在这两个方法内部会调用history 的setState，更新 transition 的listeners 数组，从而调用了 Router 的setState，进行了页面的更新
  - 浏览器前进后退，在BrowserHistory 和 hashHistory 中都在listen 的时候注册了 popState 和 hashChange 的监听事件，这里可以直接调到这个监听

![img](http://kyriejoshua.github.io/jo.github.io/2019/01/03/understanding-react-router/react-router-road.png)

1. 回调函数：含有能够更新 react UI 的 react  setState 方法
2. 注册回调：在Router.componentWillMount 中通过history.listen 注册回调函数，将对应结果存放在 changesListener 的监听数组中
3. 触发回调：
   1. Link点击触发history 中 回调数组 changesListeners 的执行，从而触发原来 listen 中的setState方法，更新页面：这里会触发该级所有的changesListener，Route组件会在render时根据真实pathname和需要匹配的path进行路由匹配和exact的判断，最后在render时只render匹配到的组件，未匹配到的组件则返回 null
   2. 浏览器前进与后退的实现：history.popState 和 onhashchange 事件

### Hash实现方式

hash的特性：改变url 的同时，不刷新页面

主要实现路由变化并监听的方法：

router对象持有 routes 对象和 currentUrl 对象，其init 时会在全局注册两个监听方法，一是 onload，而是 onhashchange，当监听到这两个事件发生时，浏览器会调用对应的refresh方法，

同时，我们可以在Route上定义route方法，也就是 routes 在routes对象中注册不同path所对应的refresh方法

```javascript
function Router() {
    this.routes = {}
    this.currentUrl = ''
}
// 路由更新方法注册
Route.prototype.route = function(path, callback) {
    this.routes[path] = callback || function(){}
}
// 路由发生变动时的更新方法
Route.prototype.refresh = function() {
    this.currentUrl = location.hash.slice(1) || '/'
    this.routes[this.currentUrl]()
}
Route.prototype.init = function() {
    window.addEventListener('load', this.refresh.bind(this), false) // 页面onload 的时候就会判断url上是否存在对应颜色的hash串，并执行对应的回调方法
    window.addEventListener('hashchange', this.refresh.bind(this), false)
}
// 下面是使用方法
window.Router = new Router()
window.Router.init() // 初始化，注册监听

function changeColor(color) {
    content.style.backgroundColor = color
}
Router.route('/', function() {
    changeColor('white'); // 添加对应路径的回调方法
})
Router.route('/green', function() {
    changeColor('green');
})

<ul>
	<li><a href="#">White</a></li> // 点击对应a标签时会触发 hash change 事件
    <li><a href="#/green">Green</a></li>
</ul>

```

**在第一次进入页面的时候，如果 url 上已经带有 hash，那么也会触发一次 onhashchange 事件，这保证了一开始的 hash 就能被识别。**



### history API

### code-splitting

// TODO 需要了解react-router 的bundle-loader 

React-router 是怎么实现路由级别的按需加载的：bundle-loader、require.ensure（延迟导入时机）

## ImmutableJS 的实现

https://juejin.im/post/5b9b30a35188255c6418e67c

用树来存储

持久化数据结构：每次修改后都会得到一个新的版本，而且旧版本可以被完整保留

1. 结构共享：每次更新state时会创建一个新的根节点，对于有修改的部分，把相应路径上的所有节点重新生成，对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是`结构共享`。这样每次操作同样会获得一个全新的版本（根节点变了，新的`a`!==旧的`a`），历史版本可以完好保留，同时也节约了空间和时间。

![1554811844250](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554811844250.png)

2. 一个Map如何成为持久化数据结构：Vector Trie

   例子：假如我们有一个 map ，key 全都是数字（当然你也可以把它理解为数组）`{0: ‘banana’, 1: ‘grape’, 2: ‘lemon’, 3: ‘orange’, 4: ‘apple’}`，为了构造一棵二叉`Vector Trie`，我们可以先把所有的key转换为二进制的形式：`{‘000’: ‘banana’, ‘001’: ‘grape’, ‘010’: ‘lemon’, ‘011’: ‘orange’, ‘100’: ‘apple’}`

   添加一个`5:'watermelon'`

   ![1554812461507](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1554812461507.png)

   1. `5: 'watermelon'` 转变为 `'101': 'watermelon'`
   2. 创建新的根节点 01
   3. 重新构造其右子树，左子树仍指向旧的左子树指针

   当map的key值不为 数字的时候，immutable实现了一套 hash 的机制，将不是数字的key值转换为数字对象（对于number、string、object、function类型的key值有不同的处理，

   - number类型则直接对这个number进行hash（number / 0xffffffff 并对这个结果进行异或，直到 number < 0xffffffff 为止），

   - string类型则会缓存一个cachedString对象，如果string键名大于某个最小长度，则从cachedString中查找有没有这个string键名对应的hash数，如果没有的话创建并放进去

     如果string键名长度小于这个最小长度，则直接生成一个hash数并返回给用户

   - object：weakMap（obj的值设置为hash之后的数值）或其他实现？？？

   - function：toString之后走string的流程

   实际情况中immutalbe map 的实现并不是二叉树，因为二叉树会在数据量变大时嵌套层级变深，实际实现中每个节点的数组长度为 32（位分区）

   `位分区`是建立在`数字分区`的基础上的，所有以2的整数次幂（2，4，8，16，32…）为基数的`数字分区`前缀树，都可以转为`位分区`。基于一些位运算相关的知识，我们就能避免一些耗时的计算。

   `数字分区`把 key 拆分成一个个数字，而`位分区`把 key 分成一组组 bit。以一个 32 路的前缀树为例，`数字分区`的方法是把 key 以 32 为基数拆分（实际上就是 32 进制），而`位分区`是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二进制位 。实际上就是把 32 进制数当成 2 进制进行操作，这样原本的很多计算就可以用更高效的位运算的方式代替。因为现在基数是 32，即`radix`为 32，所以前面的式子现在是`key / 32level - 1 % 32`，而既然`32 =``25`，那么该式子可以写成这样`key / 25 × (level - 1) % 25`。根据位运算相关的知识我们知道`a / 2n === a >>> n `、`a % 2n === a & (2n - 1) `。这样我们就能通过位运算得出该式子的值。

   **如果你对位运算不太熟悉的话，大可不看上面的式子，举个例子就好理解了**：比如数字`666666`的二进制形式是`10100 **01011** 00001 01010`，这是一个20位的二进制数。如果我们要得到第二层那五位数`01011`，我们可以先把它右移`>>>`(左侧补0)10位，得到`00000 00000 10100 **01011**`，再`&`一下`00000 00000 00000 11111`，就得到了`**01011**`。

   

## draftJS 的实现

https://marxjiao.com/2017/08/14/use-draft-js/

https://seejs.me/2018/07/29/jy_editor/ 一个富文本编辑器实例的实现

## 具体问题

如果有个组件嵌套层级较深，数据怎么获取比较好



