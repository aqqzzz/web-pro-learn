面试问题

# 网络

## cookie 和 session 

### cookie

cookie的访问方式有两种，

- 通过js访问，document.cookie返回当前页面的可用cookie，但是这种情况下很容易被黑客窃取cookie信息，可以通过生成cookie时设置 HttpOnly 属性为true，限制cookie只能在http发送请求时携带
- 设置cookie时会设置domain域名，当用户向这个域名发送请求时，浏览器会自动去自己存储的cookie列表中（这个列表包含所有cookie，包含httponly的，而且同一域名下可能会有多个cookie），查找到当前域名下的所有cookie，然后加到 http请求中发送给服务器（如果是fetch请求的话需要设置 withCredentials:true 浏览器才会在http请求中加cookie），服务器收到后查找最匹配的cookie并进行响应操作（？？？？是客户端把所有cookie都发送给服务器吗）
  - 一般cookie是由服务端生成的，服务端通过在发送给客户端的响应报文头中设置 set-cookie 字段来设置cookie
  - 客户端自己可以通过设置 document.cookie 来**添加**一个新的cookie（不会覆盖已有cookie，除非设置cookie 的 name、value、domain、path 都和一个已存在的cookie重复）

session

sessionStorage

cookieStorage

https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API

## HTTP

### 为什么 HTTPS 网站不能发送 HTTP 请求

混合内容：在HTTPS网站中使用HTTP发送了请求（script 或者 img src 或者 请求），http请求没有安全保障，可能会被中间代理人或其他恶意网站劫持而对用户的网站造成伤害

- 通过简单的script引入不安全的http请求：攻击者可以将代码注入返回的内容，并控制整个页面
- 通过请求（XMLHttpRequest 或 fetch）获取的数据用于更新innerHTML

### HTTP 和 HTTPS 的区别，主要用了什么加密算法

1. HTTPS协议需要CA证书

2. HTTP协议运行在TCP上，所有传输的内容都是明文

   HTTPS协议运行在SSL/TLS上，SSL运行在TCP上，所有传输内容经过加密

3. 端口不同：HTTP：80、HTTPS：443

### HTTP1.0、HTTP1.1、HTTP2.0

#### HTTP1.0和HTTP1.1的区别

1. **缓存处理**：
   - HTTP1.0：if-Modified-since，Expires
   - HTTP1.1：ETag、If-None-Match、Last-Modified、If-Unmidified-Since

2. **带宽优化及网络连接**
   - HTTP1.0：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
   - HTTP1.1：请求头引入 range域，允许之请求资源的某个部分（返回206）
3. **错误通知**（状态码）HTTP1.1新增
   - 409：conflict 请求资源与资源的当前状态发生冲突
   - 410：Gone 服务器上某个资源被永久性删除
4. **Host头处理**
   - HTTP1.0：认为每台服务器绑定一个唯一的IP地址
   - HTTP1.1：服务器中产生 虚拟主机，一个物理服务器上可以有多个虚拟主机，并且它们共享一个IP地址。所以HTTP1.1 的请求消息中必须用Host头域来指定 请求的主机名
5. **长连接**
   - HTTP1.0：默认关闭长连接，只有设置`Connection: keey-alive` 才能开启长连接
   - HTTP1.1：默认开启长连接，只有设置`Connection: close` 才能关闭连接
   - 长连接的好处：
     - 在一个TCP连接上可以传送多个HTTP请求和响应
     - 减少建立和关闭TCP的时延
     - 减少慢启动时延

#### HTTP2.0 和 HTTP1.x相比的新特性

- **二进制格式**。

  - HTTP1.x解析基于文本，需要考虑更多健壮性场景
  - 2.0只使用二进制

- **多路复用**：连接共享

  一个连接上可以有多个request，每个request可以随机混杂在一起，接收方可以根据request的id 将request再归属到各自不同的服务端请求里

- **header压缩**：使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields 表

- **服务端推送**：可以把客户端需要的资源伴随 index.html 一起发送到客户端，省去了客户端重复请求的步骤

#### HTTP2.0 多路复用 和 HTTP1.x中的长连接复用的区别

- HTTP1.0：一次请求-响应，建立一个连接，用完关闭（每个请求都要建立一个连接）
- HTTP1.1：若干个请求**串行化单线程**处理，后面的请求等待前面请求返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞——线头阻塞
- HTTP2.0：多个请求可以同时在一个连接上**并行**执行，一个请求耗时严重不会影响其他连接的正常执行

![1552811110029](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552811110029.png)

### 缓存 cache-control



### HTTP事务的时延

1. DNS解析：如果最近没有访问过这个URL（即缓存中没有这个URL）
2. TCP事务时延导致HTTP事务时延

### CA证书是什么，如何判定合法

## TCP

### TCP事务的时延

1. TCP连接握手时延

2. TCP延时确认机制造成的时延：

   延时确认：每个TCP报文段到达接收方的时候，接收方都会回送一个ack报文给发送方。而延时确认就是搞一个缓冲区，把ack报文放进去，当接收方这边有需要发送给发送方的数据的时候，把ack报文放进去 “捎带”给发送方，如果一直没有数据需要发送，那么会设置一个超时时间，超过这个时间就会单独把ack报文发回去

   HTTP具有双峰特征的请求 - 应答行为降低了捎带信息的可能，当希望有相反方向回传分组的时候，偏偏没有那么多。所以延迟确认算法会引入很大的时延

   为什么延时确认会引入时延？TCP滑动窗口

   ![1552807107448](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807107448.png)

   ![1552807131709](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807131709.png)

3. TCP慢启动

   TCP连接刚刚建立的时候会有这种策略

   限制一个TCP端点在任意时刻可以传输的分组数，每成功接收一个分组，发送端就有了发送另外两个分组的权限（这个时候是需要确认上一个tcp之后才能发送下一个）+——打开拥塞窗口（调谐）

   但是这个传输分组的数量是有上限的，到达上限之后就不需要重新确认了

4. Nagle算法

   - 充分利用带宽，鼓励每次tcp报文都发送全尺寸的段
   - 将小尺寸的分组数据放在缓存区
   - 只有接收到上一次tcp请求的ack，才能将缓存区中的内容发出去
   - 和 延时确认算法一起使用时，会造成每个tcp请求都被延时

### TCP请求建立 三次握手，是否每次请求都需要三次握手



## 性能优化

### 从一个url页面到页面显示步骤

https://mp.weixin.qq.com/s/z8aJZ14NAc-qXx3Qt4gZLQ

### 页面渲染步骤

### 首页加载缓慢，优化

### 安全

前端安全性措施

- 不要使用 dangerouslySetInnerHtml
- react 自带防 xss
- 用户退出后清理 localStorage
- 用https
- 不要再get请求里存放 username和password

有 src 属性的标签都是可以跨域请求的

比如

- `<img>` 在更改 src 属性的时候就会发请求

- script、iframe、link[rel=stylesheet]，在标签添加到DOM树之后才会发请求（iframe标签可以load不同域的src，但是该iframe下的js代码不能拿到原不同域parent对象的js对象）

- 原生form表单提交中，action设置的 发送请求url是没有跨域限制的

  - 为什么说form表单提交没有跨域限制而 ajax请求有跨域限制：不设target的表单提交只负责发请求，不等待请求结果，post结束之后页面全部刷新，原页面的脚本无法获取新页面中的内容，所以浏览器认为这个是安全的。而ajax是可以读取响应内容的

  - 如何使用 form 表单实现无刷新表单提交：

    - 把 form 提交到本域的一个空iframe 中，让服务器处理完之后跳转到同域的空白页里，并给这个空白页添加返回后的数据

    - 跨域：window.name / window.domain / window.postMessage

    - 当数据接口A 在B空白页面加载数据请求时，会将返回的数据存放在url中，通过解析url的query就能取回返回的数据啦~

      通过监听隐藏iframe的onload事件，就可以触发父页面的callback函数啦~

    - http://www.dengzhr.com/js/1346

#### XSS攻击

网页中某个html内容值是由 url 的 searchParam 设置的，若将searchParam修改为一个 可以引发某些恶意操作的 javascript 语句，那么这个 html 嵌入之后会执行这段代码，从而达到攻击的目的

- 恶意的 js 代码有几种形式：
  - `<script>xxx</script>`：这种情况可以用 escapeHTML(str) ，对特殊字符进行转义，从而让浏览器知道这段字符只是一个文本，而不是需要被执行的真实html语义标签
  - 在标签中进行跳转时，可以设置 `<a href='javascript:js代码'`：浏览器解析过程：只要包含 javascript: ，其后的js代码就会被执行，可以通过构造白名单的方式（即设置一个href跳转时允许的start列表，如['http', 'https']），过滤所有没有意义或者恶意的href 指向

在`<script>`代码执行标签中可能会设置 JSON 数据，JSON数据是不能用 escapeHTML 来转义的，否则会破坏 JSON 数据本身的含义，此时如果在JSON数据中包含一个 `</script>`闭合标签，浏览器就会认为后面的代码为 HTML，从而，可以继续在之后的代码中插入 `<script>` 来执行想要执行的恶意代码

<script>
	var initData = <%=data.toJSON() %>    
</script>

可以自己实现一个HTML的转义库（简易版），如将< 和 > 转换为对应的转义字符

或者直接使用业界通用的转义库

##### 分类

https://excess-xss.com/

- 存储型XSS
  - 攻击步骤：
    - 攻击者将恶意代码提交到目标服务器的数据库中（如论坛发帖）
    - 用户打开目标网站时，网站服务器将恶意代码从服务器中取出，拼接在HTML中返回给客户端（？？？）
    - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    - 恶意代码窃取用户的信息并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作
  - 适用范围：常用于带有用户数据保存功能的网站，比如论坛发帖、用户评论、用户私信等
- 反射型XSS
  - 恶意代码存在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的URL，其中包含恶意代码
    - 用户打开带有恶意代码的URL，**网站服务器**将恶意代码从URL中取出，拼接在URL中返回给浏览器
    - 用户浏览器接到响应后解析执行，混在其中的恶意代码也被执行
    - 同存储型最后一步
  - 适用范围：常用于通过URL传递参数的功能，如网站搜索、跳转等
  - 另：POST方式需要构造表单并诱导用户点击 ？？？？
- DOM-XSS
  - 恶意代码也在URL里
  - 攻击步骤：
    - 攻击者构造出特殊的 URL，其中包含恶意代码。
    - 用户打开带有恶意代码的 URL。
    - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
  - 取出和执行恶意代码完全由 浏览器端完成，为Javascript前端的安全漏洞

##### 预防

- DOM型：
  - 使用 `.textContext` 和 `.setAttribute` 来替代 `.innerHTML`、`.outerHTML`、`document.write()`
  - 技术栈，react，少使用 dangerouslySetInnerHTML
  - 注意那些可以把字符串当做代码运行的部分：
    - DOM中的内联事件监听器：location、onclick、onerror、onload、onmouseover 等
    - <a 标签的 href 属性
    - javascript 代码 setInterval、setTimeout
- 跟服务端相关的两种类型
  - 选取合适的 HTML转义库
  - 注意拼接HTML的操作，尽量使用createElement等行为来生成 dom元素
  - 纯前端渲染？？
    - 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
    - 然后浏览器执行 HTML 中的 JavaScript。
    - JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

#### CSRF攻击

https://www.tuicool.com/articles/7Ff2EbZ

跨站请求伪造，在访问黑客网站时的操作会被操作到其他网站上

- 利用 img、script、iframe 的src标签可以请求跨域资源的特性，通过这些src来请求一些不规范的get请求（本应该是修改数据的post请求但是可能由于安全疏忽写成了get请求）
- post请求处理关键业务，利用 界面原生 form 表单可以跨域提交的特性，再加上空白iframe实现无刷新，可以再用户不知情的前提下实现跨域发送伪造请求

解决办法：

可以使用csrf-token的方式，服务端生成csrf-token，并通过服务端渲染的方式，将其设置到隐藏 form表单中 发送给用户，用户每次提交post请求时都会自动添加这个form表单中的csrf-token，服务端通过验证token即可得知当前请求是不是原站发过来的真实请求

## CDN



# typescript

继承和实现的区别

https://juejin.im/entry/5981c5df518825359a2b9476

# Javascript

## es6

### class

如果父类有方法不想让子类继承，需要怎么做

#### class 是 Function 的语法糖，那么class 和 function有哪些区别

1. class 内部只能有 构造函数constructor、方法、存值取值函数（get\set）、属性表达式（\[:expression]()）

2. class 只能用new 来声明，不能直接按照普通函数调用那样使用

3. class内部自动声明为严格模式

4. class类不存在变量提升（方便“继承”的使用）

5. 类 相当于 实例的原型，所有在类中定义的方法，都会被实例继承

6. 可以定义**静态方法**，static 关键字——该方法只能直接通过类来进行调用（**静态方法中的this 指的是 这个class（即实例原型），而不是实例**

   静态方法可以被继承

7. **静态属性**，定义在 class 上，而不是实例上的属性 ( 只能在class外部定义Class.prop = 1 )

### promise

promise的then

promise 的then函数中是如何获取上次resolve的值的

同一个promise对象a，对此执行a.then 会有什么反应

### async/await

await 具体作用是什么

## es7



## webpack

介绍、loader

## 跨域

https://harttle.land/2015/10/10/cross-origin.html#header-5

同源策略：协议、域名、端口都相同，才可以

- 读取 Cookie、localStorage、indexDB
- 获取DOM 和 JS 对象
- 发送AJAX请求

解决跨域问题的几种方法

1. jsonp：原理：浏览器允许将js、css、img等静态资源分离到另一台独立域名的服务器上，通过这个与当前域名不同的服务器来加载静态资源

   动态创建script，请求一个带参网址来实现通信

   缺点：只能发送get一种请求

2. document.domain + iframe

   - 原理：两个页面通过js设置document.domain为同一主域从而实现同域（仅限于两个页面主域相同，子域不同的情况）
   - 只能获取不同域的 dom 和 js 对象

3. location.hash + iframe

   - 不同域的iframe只能，父窗口设置子窗口的hash值，子窗口不能获取父窗口 js 相关信息
   - 实现方式：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

4. window.name + iframe

   - 原理：name值在不同的域名加载后仍然存在，只要浏览器标签页不关闭，name值就不变
   - 实现方式：可以在window.name中记录想要跨域传输的信息
     - 当请求不同域的信息时，在该被请求文件中设置 window.name  值为想要传递的信息，在当前页面中创建一个iframe，src设置为该被请求文件路径，iframe onload的时候，这个window.name 已经被设置了，之后再将iframe 的src设置为与当前文件同域名的一个空文件，并读取其中的window.name值，从而实现js的通信

5. html5 postMessage

   - 用于解决以下问题
     - 页面和其打开的新窗口之间的消息传输
     - 多窗口之间消息传递
     - 页面与嵌套的iframe消息传递

## canvas

绘图、canvas鼠标事件、判断点在复杂图形内部

## 原理

### instanceof 原型链

Array的prototype是否可以修改

### 块级作用域

const一个函数，能否修改这个函数的this？

答：函数this的指向，如果没有绑定，在调用的时候确定，但是也可以对它进行this指向的修改（如bind等操作，这个时候会返回一个新的函数放到堆内存里，对原函数没有影响），和const无关

## 具体问题

### 大数相加（包含负数）

### 实现一个简单的Promise

### 数组去重，里面有对象，数组

### 深拷贝的两种方法

（对象、数组、函数

### 实现reduce

### 金额加逗号



# 算法

https://github.com/azl397985856/leetcode



## 排序

https://www.cnblogs.com/onepixel/articles/7674659.html

### 快排

### 冒泡



## 动态规划

如何找到两个数组的最长相同子序列

### 其他问题

抽牌算法

# css

如何用css实现一个左右两栏高度与中间块高度同高的布局

### 布局

flex、grid、position、float

#### 绝对定位和相对定位的区别



# react

### 和jquery的区别

### diff的过程（为什么还需要shouldComponentUpdate）

- renderTree同层比较
- 三种操作：Add、Remove、Move（通过key对比实现）

为什么还需要 shouldComponentUpdate？

因为js diff运算也是耗费资源和时间的，如果可以根据prop或者state判断不需要修改，可以省下 diff运算的资源耗费

### react connect 和 Provider的作用是什么

### react页面切换动画怎么做

### PureComponent 和 普通组件的区别是什么

### setState异步更新 

在React中，**如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state**。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。

在React的setState函数实现中，会根据一个变量**isBatchingUpdates**判断是直接更新this.state还是放到队列中回头再说，而***isBatchingUpdates***默认是false，也就表示setState会同步更新this.state，但是，有一个函数**batchedUpdates**，这个函数会把***isBatchingUpdates***修改为true，而当React在调用事件处理函数之前就会调用这个**batchedUpdates**，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。

### react生命周期

#### 15版本

![img](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageslim)

#### 16版本

![1553688093737](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1553688093737.png)

- constructor：初始化state、给实例绑定 事件处理函数
  - constructor中不应该调用 setState
- **static** getDerivedStateFromProps(nextProps, prevState)
  - 在 render 之前被调用
  - 在prevState中存储想要获取的prevProp，用来跟nextProp比对
  - 返回值为更新之后的state（整个替换）
  - **只能执行纯函数操作**：输出完全依赖于输入，不能执行副作用过程
- shouldComponentUpdate(nextProps, nextState)
  - 接收到新的state或props时调用，默认返回true
  - 首次render和forceUpdate()过程不会调用这个生命周期函数
  - return false 只能阻止当前组件重新render，不能阻止子孙组件重新render
  - 如果是为了“阻塞”某次更新的话，应该考虑使用 PureComponent，它会对props和state做一次浅比较
- getSnapshotBeforeUpdate(prevProps, prevState)
  - 最近一次render的结果要被提交给dom之前调用，可以在DOM更新前获取一些信息
  - 返回值会被当作第三个参数传递给 componentDidUpdate
  - 需要返回null或一个默认值
- componentDidMount
  - 发送请求获取数据
  - 注册事件（需要在unmount中取消事件）
  - 在这里**立即**调用setState时，render会被调用两次，但真正实际的dom更新只有一次？？？
- componentDidUpdate(prevProps)
  - 更新完成后操作DOM节点
  - 对比props之后可以发送请求获取数据
- componentWillUnmount



#### 为什么说 componentWillUpdate 和 componentWillReceiveProps 会被调用多次，而componentDidUpdate 只会被调用一次

react 16 Fiber架构，两个阶段

- reconcile阶段：可以被打断
  - prop/state更新->生命周期函数 -> 虚拟dom -> diff -> 修改真实dom
  - 可能被调用的生命周期函数：
    - componentWillMount
    - componentWillUpdate
    - componentWillReceiveProps
    - shouldComponentUpdate
- commit阶段：不可以被打断
  - 可能被调用的生命周期函数
    - componentDidUpdate
    - componentDidMount
    - componentWillUnmount

Fiber 是比 thread 更细的粒度，js是单线程的，fiber就是让react在reconcilation阶段，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务需要更新

- 有的话，做紧急任务，当前分片的更新过程作废
- 没有的话继续执行下一个分片的更新任务

### key的作用

## react-router

如何自己实现一个router，如何监听路由变化

### hash API

### history API

## 具体问题

如果有个组件嵌套层级较深，数据怎么获取比较好



