面试问题

# 网络

## HTTP

### 为什么 HTTPS 网站不能发送 HTTP 请求

混合内容：在HTTPS网站中使用HTTP发送了请求（script 或者 img src 或者 请求），http请求没有安全保障，可能会被中间代理人或其他恶意网站劫持而对用户的网站造成伤害

- 通过简单的script引入不安全的http请求：攻击者可以将代码注入返回的内容，并控制整个页面
- 通过请求（XMLHttpRequest 或 fetch）获取的数据用于更新innerHTML

### HTTP 和 HTTPS 的区别，主要用了什么加密算法

1. HTTPS协议需要CA证书

2. HTTP协议运行在TCP上，所有传输的内容都是明文

   HTTPS协议运行在SSL/TLS上，SSL运行在TCP上，所有传输内容经过加密

3. 端口不同：HTTP：80、HTTPS：443

### HTTP1.0、HTTP1.1、HTTP2.0

#### HTTP1.0和HTTP1.1的区别

1. **缓存处理**：
   - HTTP1.0：if-Modified-since，Expires
   - HTTP1.1：ETag、If-None-Match、Last-Modified、If-Unmidified-Since

2. **带宽优化及网络连接**
   - HTTP1.0：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
   - HTTP1.1：请求头引入 range域，允许之请求资源的某个部分（返回206）
3. **错误通知**（状态码）HTTP1.1新增
   - 409：conflict 请求资源与资源的当前状态发生冲突
   - 410：Gone 服务器上某个资源被永久性删除
4. **Host头处理**
   - HTTP1.0：认为每台服务器绑定一个唯一的IP地址
   - HTTP1.1：服务器中产生 虚拟主机，一个物理服务器上可以有多个虚拟主机，并且它们共享一个IP地址。所以HTTP1.1 的请求消息中必须用Host头域来指定 请求的主机名
5. **长连接**
   - HTTP1.0：默认关闭长连接，只有设置`Connection: keey-alive` 才能开启长连接
   - HTTP1.1：默认开启长连接，只有设置`Connection: close` 才能关闭连接
   - 长连接的好处：
     - 在一个TCP连接上可以传送多个HTTP请求和响应
     - 减少建立和关闭TCP的时延
     - 减少慢启动时延

#### HTTP2.0 和 HTTP1.x相比的新特性

- **二进制格式**。

  - HTTP1.x解析基于文本，需要考虑更多健壮性场景
  - 2.0只使用二进制

- **多路复用**：连接共享

  一个连接上可以有多个request，每个request可以随机混杂在一起，接收方可以根据request的id 将request再归属到各自不同的服务端请求里

- **header压缩**：使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields 表

- **服务端推送**：可以把客户端需要的资源伴随 index.html 一起发送到客户端，省去了客户端重复请求的步骤

#### HTTP2.0 多路复用 和 HTTP1.x中的长连接复用的区别

- HTTP1.0：一次请求-响应，建立一个连接，用完关闭（每个请求都要建立一个连接）
- HTTP1.1：若干个请求**串行化单线程**处理，后面的请求等待前面请求返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞——线头阻塞
- HTTP2.0：多个请求可以同时在一个连接上**并行**执行，一个请求耗时严重不会影响其他连接的正常执行

![1552811110029](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552811110029.png)

### 缓存 cache-control



### HTTP事务的时延

1. DNS解析：如果最近没有访问过这个URL（即缓存中没有这个URL）
2. TCP事务时延导致HTTP事务时延

### CA证书是什么，如何判定合法

## TCP

### TCP事务的时延

1. TCP连接握手时延

2. TCP延时确认机制造成的时延：

   延时确认：每个TCP报文段到达接收方的时候，接收方都会回送一个ack报文给发送方。而延时确认就是搞一个缓冲区，把ack报文放进去，当接收方这边有需要发送给发送方的数据的时候，把ack报文放进去 “捎带”给发送方，如果一直没有数据需要发送，那么会设置一个超时时间，超过这个时间就会单独把ack报文发回去

   HTTP具有双峰特征的请求 - 应答行为降低了捎带信息的可能，当希望有相反方向回传分组的时候，偏偏没有那么多。所以延迟确认算法会引入很大的时延

   为什么延时确认会引入时延？TCP滑动窗口

   ![1552807107448](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807107448.png)

   ![1552807131709](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552807131709.png)

3. TCP慢启动

   TCP连接刚刚建立的时候会有这种策略

   限制一个TCP端点在任意时刻可以传输的分组数，每成功接收一个分组，发送端就有了发送另外两个分组的权限（这个时候是需要确认上一个tcp之后才能发送下一个）+——打开拥塞窗口（调谐）

   但是这个传输分组的数量是有上限的，到达上限之后就不需要重新确认了

4. Nagle算法

   - 充分利用带宽，鼓励每次tcp报文都发送全尺寸的段
   - 将小尺寸的分组数据放在缓存区
   - 只有接收到上一次tcp请求的ack，才能将缓存区中的内容发出去
   - 和 延时确认算法一起使用时，会造成每个tcp请求都被延时

### TCP请求建立 三次握手，是否每次请求都需要三次握手



## 性能优化

### 从一个url页面到页面显示步骤

https://mp.weixin.qq.com/s/z8aJZ14NAc-qXx3Qt4gZLQ

### 页面渲染步骤

### 首页加载缓慢，优化

### 安全

前端安全性措施

- 不要使用 dangerouslySetInnerHtml
- react 自带防 xss
- 用户退出后清理 localStorage
- 用https
- 不要再get请求里存放 username和password

## CDN



# typescript

继承和实现的区别

https://juejin.im/entry/5981c5df518825359a2b9476

# Javascript

## es6

### class

如果父类有方法不想让子类继承，需要怎么做

#### class 是 Function 的语法糖，那么class 和 function有哪些区别

1. class 内部只能有 构造函数constructor、方法、存值取值函数（get\set）、属性表达式（\[:expression]()）

2. class 只能用new 来声明，不能直接按照普通函数调用那样使用

3. class内部自动声明为严格模式

4. class类不存在变量提升（方便“继承”的使用）

5. 类 相当于 实例的原型，所有在类中定义的方法，都会被实例继承

6. 可以定义**静态方法**，static 关键字——该方法只能直接通过类来进行调用（**静态方法中的this 指的是 这个class（即实例原型），而不是实例**

   静态方法可以被继承

7. **静态属性**，定义在 class 上，而不是实例上的属性 ( 只能在class外部定义Class.prop = 1 )

### promise

promise的then

promise 的then函数中是如何获取上次resolve的值的

同一个promise对象a，对此执行a.then 会有什么反应

### async/await

await 具体作用是什么

## es7



## webpack

介绍、loader

## 跨域

同源策略：协议、域名、端口都相同，才可以

- 读取 Cookie、localStorage、indexDB
- 获取DOM 和 JS 对象
- 发送AJAX请求

解决跨域问题的几种方法

1. jsonp：原理：浏览器允许将js、css、img等静态资源分离到另一台独立域名的服务器上，通过这个与当前域名不同的服务器来加载静态资源

   动态创建script，请求一个带参网址来实现通信

   缺点：只能发送get一种请求

2. document.domain + iframe

   - 原理：两个页面通过js设置document.domain为同一主域从而实现同域（仅限于两个页面主域相同，子域不同的情况）
   - 只能获取不同域的 dom 和 js 对象

3. location.hash + iframe

   - 不同域的iframe只能，父窗口设置子窗口的hash值，子窗口不能获取父窗口 js 相关信息
   - 实现方式：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

4. window.name + iframe

   - 原理：name值在不同的域名加载后仍然存在，只要浏览器标签页不关闭，name值就不变
   - 实现方式：可以在window.name中记录想要跨域传输的信息
     - 当请求不同域的信息时，在该被请求文件中设置 window.name  值为想要传递的信息，在当前页面中创建一个iframe，src设置为该被请求文件路径，iframe onload的时候，这个window.name 已经被设置了，之后再将iframe 的src设置为与当前文件同域名的一个空文件，并读取其中的window.name值，从而实现js的通信

5. html5 postMessage

   - 用于解决以下问题
     - 页面和其打开的新窗口之间的消息传输
     - 多窗口之间消息传递
     - 页面与嵌套的iframe消息传递

## canvas

绘图、canvas鼠标事件、判断点在复杂图形内部

## 原理

### instanceof 原型链

Array的prototype是否可以修改

### 块级作用域

const一个函数，能否修改这个函数的this？

答：函数this的指向，如果没有绑定，在调用的时候确定，但是也可以对它进行this指向的修改（如bind等操作，这个时候会返回一个新的函数放到堆内存里，对原函数没有影响），和const无关

## 具体问题

### 大数相加（包含负数）

### 实现一个简单的Promise

### 数组去重，里面有对象，数组

### 深拷贝的两种方法

（对象、数组、函数

### 实现reduce

### 金额加逗号



# 算法

https://github.com/azl397985856/leetcode

## 排序

### 快排

### 冒泡



## 动态规划

如何找到两个数组的最长相同子序列

# css

如何用css实现一个左右两栏高度与中间块高度同高的布局

### 布局

flex、grid、position、float

#### 绝对定位和相对定位的区别



# react

### 和jquery的区别

### diff的过程（为什么还需要shouldComponentUpdate）

- renderTree同层比较
- 三种操作：Add、Remove、Move（通过key对比实现）

为什么还需要 shouldComponentUpdate？

因为js diff运算也是耗费资源和时间的，如果可以根据prop或者state判断不需要修改，可以省下 diff运算的资源耗费

### react connect 和 Provider的作用是什么

### react页面切换动画怎么做

### PureComponent 和 普通组件的区别是什么

### setState异步更新 

在React中，**如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state**。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。

在React的setState函数实现中，会根据一个变量**isBatchingUpdates**判断是直接更新this.state还是放到队列中回头再说，而***isBatchingUpdates***默认是false，也就表示setState会同步更新this.state，但是，有一个函数**batchedUpdates**，这个函数会把***isBatchingUpdates***修改为true，而当React在调用事件处理函数之前就会调用这个**batchedUpdates**，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。

### react生命周期

#### 15版本

![img](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageslim)

#### 16版本

![1553688093737](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1553688093737.png)

- constructor：初始化state、给实例绑定 事件处理函数
  - constructor中不应该调用 setState
- **static** getDerivedStateFromProps(nextProps, prevState)
  - 在 render 之前被调用
  - 在prevState中存储想要获取的prevProp，用来跟nextProp比对
  - 返回值为更新之后的state（整个替换）
  - **只能执行纯函数操作**：输出完全依赖于输入，不能执行副作用过程
- shouldComponentUpdate(nextProps, nextState)
  - 接收到新的state或props时调用，默认返回true
  - 首次render和forceUpdate()过程不会调用这个生命周期函数
  - return false 只能阻止当前组件重新render，不能阻止子孙组件重新render
  - 如果是为了“阻塞”某次更新的话，应该考虑使用 PureComponent，它会对props和state做一次浅比较
- getSnapshotBeforeUpdate(prevProps, prevState)
  - 最近一次render的结果要被提交给dom之前调用，可以在DOM更新前获取一些信息
  - 返回值会被当作第三个参数传递给 componentDidUpdate
  - 需要返回null或一个默认值
- componentDidMount
  - 发送请求获取数据
  - 注册事件（需要在unmount中取消事件）
  - 在这里**立即**调用setState时，render会被调用两次，但真正实际的dom更新只有一次？？？
- componentDidUpdate(prevProps)
  - 更新完成后操作DOM节点
  - 对比props之后可以发送请求获取数据
- componentWillUnmount



#### 为什么说 componentWillUpdate 和 componentWillReceiveProps 会被调用多次，而componentDidUpdate 只会被调用一次

react 16 Fiber架构，两个阶段

- reconcile阶段：可以被打断
  - prop/state更新->生命周期函数 -> 虚拟dom -> diff -> 修改真实dom
  - 可能被调用的生命周期函数：
    - componentWillMount
    - componentWillUpdate
    - componentWillReceiveProps
    - shouldComponentUpdate
- commit阶段：不可以被打断
  - 可能被调用的生命周期函数
    - componentDidUpdate
    - componentDidMount
    - componentWillUnmount

Fiber 是比 thread 更细的粒度，js是单线程的，fiber就是让react在reconcilation阶段，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务需要更新

- 有的话，做紧急任务，当前分片的更新过程作废
- 没有的话继续执行下一个分片的更新任务

### key的作用

## react-router

如何自己实现一个router，如何监听路由变化

### hash API

### history API

## 具体问题

如果有个组件嵌套层级较深，数据怎么获取比较好



