## HTTP报文

### 报文的组成部分

#### 报文流

包含三个部分：

- 起始行：对报文进行描述
- 首部块：与主题相关的一些信息
- 主体部分（可选）

两个类型：

![1551874445069](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551874445069.png)

- 请求报文

```
<method> <request-URL> <version>
<headers>

<entity-body>
```

 1. 方法（method）：告知服务器要做些什么

    ![1551875251530](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551875251530.png)

    

- 响应报文

```
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

 	1. 状态码：告诉服务器要做什么事情

![1551875387631](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551875387631.png)

2. 原因短语：和状态码成对出现，是状态码的可读版本

##### 首部

通用首部、请求首部、响应首部、实体首部、扩展首部



#### 方法

- GET：安全方法，理论上不会在服务器上产生什么结果
- HEAD：安全方法，服务器在响应中只返回首部。
  - 客户端可以再未获取实际资源的情况下，对资源的首部进行检查（了解资源情况
  - 通过查看响应中的状态码，查看某个对象是否存在
  - 通过查看首部，测试资源是否被修改了
- PUT：向服务器写入文档，让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档
- POST：向服务器输入数据，通常用来支持HTML的表单
- TRACE：在目标服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文
- OPTIONS：请求Web服务器告知其支持的各种功能，可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法
- DELETE：请服务器删除请求URL所指定的资源。但客户端无法保证删除操作一定会被执行

#### 状态码

**200**  请求正常，实体的主体部分包含了所请求的资源

**301**  永久移动   请求的网页已经永久移动到新位置，服务器返回此响应时，响应的Location首部中应该包含资源现在所处的URL

**302**  如果HTTP/1.0服务器收到来自HTTP/1.0客户端的POST请求之后发送了302状态码，服务器就期望客户端能够接受重定向URL，并向重定向的URL发送一个GET请求

HTTP/1.1 规范使用303来实现同样的行为

**400**  Bad Request  客户端请求格式错误

**401**  Unauthorized  没有权限

**403**  Forbidden  请求被服务器拒绝。可以再包含实体的主体部分来对原因进行描述（但这个状态码通常是在服务器不想说明拒绝原因的时候使用的）

**404**  Not Found  服务器无法找到所请求的URL

**405**  Method Not Allowed  发起的请求中带有所请求的URL不支持的方法。应该在响应中包含Allow首部，以告知客户端对所请求的资源可以使用哪些方法

**415**  Unsupported Media Type   服务器无法理解或无法支持客户端所发实体的内容类型

**500**  internal Server Error  服务器遇到一个妨碍它为请求提供服务的错误

#### 首部

##### 通用首部

缓存首部

- Cache-Control：用于随报文传送缓存指示
- Pragma：另一种随报文传送指示的方式，但并不专用于缓存

##### 请求首部

- Accept首部：客户端可以用这个字段将其 想要什么， 可以用什么，  不想要什么 告诉服务器
- 条件请求首部
- 安全请求首部
- 代理请求首部

##### 响应首部

- 协商首部
- 安全响应首部

##### 实体首部

- 内容首部：提供关于实体内容有关的特定信息
- 实体缓存首部：提供与被缓存实体有关的信息，如：验证已缓存的资源副本是否仍然有效，以及更好地估计已缓存资源何时失效所需的线索。
  - Expires：实体不再有效，要从原始的源端再次获取此实体的日期和时间
  - Last-Modified：这个实体最后一次被修改的日期和时间



## HTTP缓存机制

### 缓存相关的HTTP首部字段

1. 通用首部字段

   | 字段名称      | 说明                              |
   | ------------- | --------------------------------- |
   | Cache-Control | 控制缓存的行为                    |
   | Pragma        | http1.0，值为“no-cache"时禁用缓存 |

2. 请求首部字段

   | 字段名称            | 说明                             |
   | ------------------- | -------------------------------- |
   | if-Match            | 比较ETag是否一致                 |
   | if-None-Match       | 比较ETag是否不一致               |
   | if-Modfied-Since    | 比较资源最后更新的时间是否一致   |
   | if-Unmodified-Since | 比较资源最后更新的时间是否不一致 |

3. 响应首部字段

   | 字段名称 | 说明           |
   | -------- | -------------- |
   | ETag     | 资源的匹配信息 |

4. 实体首部字段

   | 字段名称      | 说明                        |
   | ------------- | --------------------------- |
   | Expires       | http1.0，实体主体过期的时间 |
   | Last-Modified | 资源的最后一次修改的时间    |

### 石器时代的缓存方式

Pragma、Expires

1. Pragma：no-cache——每次都向服务器重新发请求

2. Expires：对应一个格林尼治时间，用于启用缓存和定义缓存时间（告诉浏览器资源缓存的过期时间，如果还没有过这个时间点的话则不发送请求）

   ​	Expires的缓存时间是相对服务器上的时间而言的，无法保证和客户端时间统一 

优先级：**Pragma > Expires**

### Cache-Control（通用首部

优先级：**Pragma > Cache-Control > Expires**

1. 作为请求首部

   | 字段名称                  | 说明                                                         |
   | ------------------------- | ------------------------------------------------------------ |
   | no-cache                  | 告知服务器不直接使用缓存，要求向原服务器发起请求（使用**缓存协商**，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 |
   | no-store                  | 所有内容都不会被保存到缓存或Internet临时文件中               |
   | max-age=delta-seconds     | 告知服务器，客户端希望接收一个存在时间（age）不大于 delta-seconds 秒的资源 |
   | max-stale[=delta-seconds] | 告知服务器，客户端愿意接收一个超过缓存时间的资源。如果定义了delta-seconds，则位超出缓存delta-seconds秒的资源，没有则为任意超出时间的资源 |
   | min-fresh=delta-seconds   | 告知服务器，客户端希望接受一个在小于delta-seconds秒内被更新过的资源 |
   | no-transform              | ~，客户端希望获取的实体数据没有被转换（比如压缩）过的资源    |
   | only-if-cached            | ~，客户端希望获取缓存的内容（如果有的话），而不用向原服务器发送请求 |
   | cache-extension           | 自定义扩展值                                                 |

2. 作为响应首部

   | 字段名称               | 说明                                                         |
   | ---------------------- | ------------------------------------------------------------ |
   | public                 | 表明任何情况下都需要缓存该资源                               |
   | Private[="field-name"] | 表明返回报文中全部或部分进开放给某些用户（服务器指定的share-user，如终端用户）作缓存使用，其他用户（如CDN等中级缓存服务器）不能缓存这些数据 |
   | no-cache               | 不直接使用缓存，要求向服务器发起（新鲜度校验）请求           |
   | no-store               | 所有内容都不会被保存或缓存到Internet临时文件中               |
   | no-transform           | 告知客户端，缓存文件时不得对实体数据做任何改变               |
   | only-if-cached         | 告知                                                         |
   | must-revalidate        | 当前资源一定是向原服务器发去验证请求的，弱请求失败会返回504（而非代理服务器上的缓存） |
   | proxy-revalidate       | 仅能用于共享缓存（如代理）                                   |
   | max-age=delta-seconds  | 告知客户端，该资源在delta-seconds秒内是新鲜的，无需向服务器发请求 |
   | s-maxage=delta-seconds | 与max-age相似，但仅用于共享缓存                              |
   | cache-extension        | 自定义扩展值                                                 |

Cache-Control 可以自由组合可选值

```
Cache-Control: max-age=3600, must-revalidate
```

该资源是从原服务器上获取的，而且其缓存的有效时间为一小时，在之后的一小时内，用户重新访问该资源则无需发送请求

### 缓存校验字段

前面的首部字段的作用是：让客户端决定是否向服务器发送请求

问题：**如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢**

缓存校验字段：让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率

#### 1. Last-Modified

1. 服务器 -> 客户端，将资源最后更改的时间加在 实体首部 上一起返回给客户端

2. 客户端为资源标记该信息

3. 下次再次请求该资源时，客户端把该信息附带在请求报文中一并带给服务器去做检查

   - 若传递的时间值与服务器上该资源最终修改时间一致，则说明该资源没有被修改过——返回304状态码，内容为空
   - 若两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求类似

   ![1551954176714](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551954176714.png)

   请求报文首部字段

   1. If-Modified-Since: Last-Modified-value

      告诉**服务器**，如果客户端传来的最后修改时间与服务器上的**一致**，则直接回送`304` 和响应报头即可

      当前各浏览器均使用该首部来向服务器传递保存的 Last-Modified 值

   2. If-Unmodified-Since: Last-Modified-value

      告诉**服务器**，若 Last-Modified 没有匹配上（资源在服务端的最后更新时间改变了），应该返回`412`

   **Last-Modified的缺点**：如果在服务器上，一个资源被修改了，但其实际内容根本没有发生改变，会因为Last-Modified 的时间匹配不上而返回了整个实体给客户端

#### 2. ETag（实体首部）

解决Last-Modified 不准确的问题

Etag字段：

1. 服务器通过某种算法，给资源计算得出一个唯一标识符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag：唯一标识符”一起返回给客户端
2. 客户端保留该ETag字段
3. 在下一次请求时，客户端将该字段一并带过去给服务器，服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就可以判断资源相对客户端是否被修改过了
   - ETag一致：返回304
   - 不一致：返回200、新资源+新的Etag给客户端

请求报文首部字段（客户端如何把表在资源上的ETag回传给服务器）

1. If-None-Match: ETag-value

   告诉**服务器**，如果ETag没匹配上需要重新发送资源，否则直接回送`304`和响应报头即可

   当前各浏览器均使用该请求首部来向服务器传递保存的ETag值

2. If-Match: ETag-value

   告诉**服务器**，如果服务器没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则返回`412`

【注】CDN中需要将服务器上计算ETag唯一值的算法保持一致，否则不同服务器生成的ETag不同

### 缓存头部对比

| 头部          | 优势和特点                                                   | 劣势和问题                                                   |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Expires       | 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。 2、以时刻标识失效时间。 | 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。 2、存在版本问题，到期之前的修改客户端是不可知的。 |
| Cache-Control | 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2、比Expires多了很多选项设置。 | 1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2、存在版本问题，到期之前的修改客户端是不可知的。 |
| Last-Modified | 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。 | 1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 2、以时刻作为标识，无法识别一秒内进行多次修改的情况。 3、某些服务器不能精确的得到文件的最后修改时间。 |
| ETag          | 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 2、不存在版本问题，每次请求都回去服务器进行校验。 | 1、计算ETag值需要性能损耗。 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。 |

具体例子和验证方式见：https://imweb.io/topic/5795dcb6fb312541492eda8c

缓存相关的两个面试题：https://zhuanlan.zhihu.com/p/24467558

### 强缓存和协商缓存

#### 强缓存：

Expires 和 Cache-Control

普通刷新会忽略它，但不会清除它，需要强制刷新

强制刷新：

```
Cache-Control: no-cache
Pragma: no-cache
```

#### 协商缓存

由服务器来确定缓存资源是否可用

普通刷新会**启用弱缓存，忽略强缓存**，只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存

`ETag` 和 `If-None-Match`

`Last-Modified` 和 `If-Modified-Since`

https://segmentfault.com/a/1190000008956069



## 连接管理

### TCP连接

TCP流式分段的，由IP分组传送

HTTP over TCP over IP

HTTPS：在HTTP和TCP之间插入了一个（成为 TLS 或 SSL 的）密码加密层

![1551963229326](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551963229326.png)

**IP分组的构成**

- 一个IP分组首部（通常为20字节）：包含源和目的IP地址、长度和其他标记
- 一个TCP段首部（通常为20字节）：包含TCP端口号、TCP控制标记、用于数据排序和完整性检查的一些数字
- 一个TCP数据块（0个或多个字节）

**TCP连接识别**：通过端口号来保持TCP连接的正确性

<源IP地址、源端口号、目的IP地址、目的端口号>

以上4个值一起唯一定义一条连接

![1551963655029](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1551963655029.png)

书page 83

## Web服务器

实际的Web服务器会做些什么

1. 建立连接——接受一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭
2. 接受请求——从网络中读取一条 HTTP请求报文
3. 处理请求——对请求报文进行解释，并采取行动
4. 访问资源——访问报文中指定的资源
5. 构建响应——创建带有正确首部的HTTP响应报文
6. 发送响应——将响应回送给客户端
7. 记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中

### 第二步，接受请求时

连接上有数据到达时，Web服务器会从网络连接中读取数据，并将请求报文中的内容解析出来

解析请求报文时，Web服务器会：

- 解析请求行，查找请求方法、指定的资源标识符（URI）以及版本号，各项之间由一个空格分隔，并以一个回车换行序列作为行的结束
- 读取以CRLF结尾的报文首部
- 检测到以CRLF结尾的、标识首部结束的空行
- 读取请求主体



## Cookie和Session

HTTP协议无状态，Cookie最早是用于记录用户状态的

具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。

![1552051301628](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552051301628.png)

cookie罐：不同的站点使用不同的cookie，浏览器只向服务器发送服务器产生的那些cookie

重要的两个属性

1. cookie的域属性：domain

   产生cookie的服务器会将set-cookie响应首部添加domain来控制，哪些站点可以看到这个cookie，所有domian中声明的域和其子域，都可以看到这个cookie

2. cookie的路径属性：path

    某域名下该path和该path子路径的请求访问都可以拿到对应的cookie

### cookie与会话跟踪（session）

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。

其实session也是依赖cookie实现的，需要在客户端使用cookie存储生成的sessionid

#### 问题：如果禁用了cookie怎么办

最好的办法是使用 localStorage（localStorage是不能跨域的） + 自定义header 传递sessionid

次之可以将sessionid放在url里传到服务器，但是这种方式很不安全

- 浏览器存储历史记录，可能会被利用
- 可能在日志系统里，或者 访问的第三方资源 可以拿到请求头

#### Cookie和Session的对比

**1、存取方式的不同**

Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。

而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。

**2、隐私策略的不同**

Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。


假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。

**3、有效期上的不同**

使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。

由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。

**4、服务器压力的不同**
Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。

而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。

**5、浏览器支持的不同**
Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。

假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。

假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）

**6、跨域支持上的不同**

Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。



## HTTP认证

### 基本认证

![1552114643471](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552114643471.png)

![1552114660591](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552114660591.png)

#### 安全缺陷

1. 通过网络发送用户名和密码（以一种很容易解码的形式表示，如Base-64）——需要通过SSL加密信道发送所有的HTTP事务，或者使用更安全的认证协议，比如摘要认证
2. 即使密码以更难解码的方式加密，第三方让然可以捕获修改过的用户民个密码，并将更改过的用户名和密码一次次地重放给原始服务器，以获得访问权（重放攻击）
3. 个人不良习惯问题：多个服务间使用相同的用户名密码
4. 没有提供针对代理和作为中间人的中间节点的防护措施
5. 假冒服务器很容易骗过基本认证



### 摘要认证

改进：

- 永远不会以明文方式在网络上发送密码
- 可以防止恶意用户捕获并重放认证的握手过程
- 可以有选择地防止对报文内容的篡改
- 防范其他几种常见的攻击方式

使用 传输层安全（TLS）和 安全HTTP（HTTPS）协议 更加合适

改进措施：

1. 用摘要保护密码

   摘要：对信息主体的浓缩，是一种单向函数，用于将无限的输入值转换为有限的浓缩输出值（如MD5）

   不知道密码，猜出摘要很难，知道摘要推出密码也很难

2. 用随机数防止重放攻击

   即使不知道密码，只要可以截获摘要，并一遍遍地重放给服务器，摘要和密码一样好用

   防范措施：随机数

   - 服务器向客户端发送一个成为 **随机数** 的特殊令牌，这个数会经常发生变化。
   - 客户端在计算摘要之前先将这个随机数令牌附加到密码上去

   每次发送给服务端的随机数是不同的，避免了重放攻击

3. 摘要认证的握手机制

   1. 服务器计算随机数

   2. 服务器将这个随机数放在WWW-Authenticate质询报文中，与服务器所支持的算法列表一同发往客户端

   3. 客户端选择一个算法，计算出密码和其他数据的摘要

   4. 将摘要放在一条Authorization报文中发回服务器。如果客户端要对服务器进行 认证，可以发送**客户端随机数**

   5. 服务器接受摘要、选中的算法以及支撑数据，计算出与客户端相同的摘要。然后服务器将本地生成的摘要与网络传送过来的摘要进行比较，验证器是否匹配

      如果客户端反过来用客户端随机数对服务器进行质询，就会创建客户端摘要。服务器可以预先将下一个随机数计算出来，提前将其传递给客户端，这样下一次客户端就可以预先发送正确的摘要了。

![1552118812718](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552118812718.png)

摘要认证和基本认证的对比

![1552118922169](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552118922169.png)

### 对称认证

扩展摘要认证机制，允许客户端对服务器进行认证。这是通过提供客户端随机值来实现的，服务器会根据它对共享保密信息的正确了解生成正确的响应摘要。然后，服务器在Authorization-Info首部中将次摘要返回给客户端

## 安全HTTP

HTTPS：所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPs在HTTP下面提供一个传输级的密码安全层（SSL、TLS）

![1552122386189](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552122386189.png)

### 常用加密编码技术：

#### 1. 数字加密

数字密钥是编/解码算法的输入。编码算法就是一些函数，这些函数会读取一块数据并根据算法和秘钥值对其进行编/解码

编/解码函数是互为反函数的

每个不同的秘钥值可以对应不同的编/解码算法，可以从一个加密算法中产生出数万亿的虚拟加密算法，由不同的密钥值来区分不同的算法

#### 2. 对称密钥加密技术

发送端和接收端要共享相同的秘钥k才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，会付出原始的明文

为每对主机使用单独的加密/解密密钥

缺点：如果有N个节点，每个节点都要和其他所有N-1个几点进行安全对话，总共大概会有N^2个保密密钥——管理噩梦

#### 3. 公开密钥加密技术

使用两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码

1. 对主机报文进行编码的秘钥——公开的
2. 对主机报文进行解码的秘钥——私有的

只有接收端才能对发送给它的报文进行解码

例：所有人都知道节点X的编码密钥，只要想给他发送报文，使用这个密钥编码即可。但是只有节点X知道收到的报文要怎么解码（只有X拥有解码密钥）

#### 4. 数字签名

签名：说明是谁编写的报文，同时证明报文未被篡改过

数字签名是附加在报文上的特殊加密校验码，使用数字签名的好处：

1. **签名可以证明是作者编写了这条报文**。只有作者才会有最机密的私有密钥，因此，只有作者才能计算出这些校验和
2. **签名可以防止报文被篡改**。如果有恶意攻击者在报文传输过程中对齐进行了修改，校验和就不再匹配了（校验和只有作者保密的私有密钥才能产生）

【例】节点A向节点B发送一条报文，并对其进行签名

1. 节点A将变长报文提取为定长的摘要
2. 节点A对摘要应用了一个“签名”函数，这个函数会将用户的私有密钥作为参数。图中，由于解码函数D中包含了用户的私有密钥，所以我们将其作为签名函数使用。
3. 一旦计算出签名，节点A就将其附加在报文的末尾，并将报文和签名都发送给B
4. 在接收端，如果节点B需要确定报文确实是节点A写的，而且没有被篡改过，节点B就可以对签名进行检查。节点B接收经私有密钥扰码的签名，并应用了使用公开密钥的反函数。如果拆包后的摘要与节点B自己的摘要版本不匹配，要么就是报文在传输过程中被篡改了，要么就是发送端没有节点A的私有密钥（也就是说它不是节点A）

![1552183452583](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552183452583.png)

#### 5. 数字证书

包括：

- 对象的名称（人、服务器、组织等）
- 过期时间
- 证书发布者（由谁为证书担保）
- 来自证书发布者的数字签名
- 对象的公开密钥，以及对象和所用签名算法的描述性信息

![1552183688484](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552183688484.png)

用证书对服务器进行认证

服务器证书中包含：

- Web站点的名称和主机名
- Web站点的公开密钥
- 签名颁发机构的名称
- 来自签名颁发机构的签名

浏览器中会预先安装很多签名颁发机构的证书，当它收到证书时，会对签名颁发机构进行检查，如果这个机构是个很有权威的公共签名机构，则浏览器可能哥已经知道其公开密钥了（预先安装的证书）。如果对签名颁发机构一无所知，浏览器就无法确定是否应该信任这个签名颁发机构，它通常会向用户显示一个对话框，看看他是否相信这个签名发布者

![1552184036181](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552184036181.png)

### HTTPS

HTTP的安全版本，将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起

HTTPS协议在将HTTP报文发送给TCP之前，先将其发送给了一个安全层，对其进行加密

HTTP安全层：通过SSL及其现代替代协议TLS实现。

![1552185578177](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552185578177.png)

#### HTTPS方案

请求一个客户端对某Web资源执行某事务时，它回去检查URL的方案

- 如果URL的方案为http，客户端就会打开一条到服务器端口**80**（默认）的连接，并向其发送老的HTTP指令
- 如果URL的方案为https，客户端就会打开一条到服务器端口**443**（默认）的连接，然后与服务器“握手”，以二进制格式与服务器交换一些SSL安全参数，附上加密的HTTP命令。

#### SSL握手

完成以下工作：

- 交换协议版本号
- 选择一个两端都了解的密码
- 对两端的身份进行认证
- 生成临时的会话密钥，以便加密信道

![1552185147583](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552185147583.png)

#### 服务器证书

安全HTTPs事务总是要求使用服务器证书

![1552185315152](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552185315152.png)

站点证书有效性检验（浏览器端）：

- 日期检测（起始日期和结束日期）
- 签名颁发者可信度检测
- 签名检测：浏览器对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性
- 站点身份监测：浏览器会验证证书中的域名与他们所朵花的服务器的域名是否匹配

#### 代理

普通的代理通过读取HTTP首部来判断请求应该转向何处，但是HTTPS 中，如果客户端使用服务器的公开密钥对发往服务器的数据进行了加密，代理就不能读取HTTP 首部了

HTTPS 隧道协议：客户端首先告知代理，它想要连接的安全主机和端口。这是在开始加密之前，以明文形式告知的

### HTTP 和 HTTPS 的区别

http是HTTP协议运行在TCP之上（80）。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

https是HTTP运行在SSL/TLS之上（443），SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份

## DNS

根域名 -> 顶级域名(.com .net) -> 次级域名 （.example.com 中的 .example

-> 主机名/三级域名(host www.)

主机名.次级域名.顶级域名.根域名

### 分级查询

1. 从“根域名服务器”查到“顶级域名服务器”的NS记录（指向该级域名的域名服务器）和A记录（IP地址）
2. 从“顶级域名服务器”查到“次级域名服务器”的NS记录和A记录（IP地址）
3. 从“刺激域名服务器”查出“主机名”的IP地址

根域名服务器的NS记录和IP地址一般不会变化，所以内置在DNS服务器里

## HTTP协议分层

http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html

![1552188335209](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552188335209.png)

![1552188353646](C:\Users\张文玘\AppData\Roaming\Typora\typora-user-images\1552188353646.png)

实体层：电脑连接起来的物理手段，规定网络的一些电气特性（传递0和1）

链接层：以太网（MAC地址、广播，但是只局限于同一个子网内的交流）

网络层：IP协议，区分MAC地址的子网络（172.16.254.1），建立主机到主机的连接

- 引进一套新的地址——网络地址，网络地址与MAC地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起

- 使用子网掩码和IP地址共同判断，两个IP地址是否属于同一个子网
- ARP协议（只局限于 两台主机在同一个子网）：发出一个数据包，其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填FF:FF:FF:FF:FF:FF，表示这是一个“广播”地址。它所在子网络的每一台主机，都会受到这个数据包，从中取出IP地址，与自身的IP地址进行比较，如果两者相同，则作出回复，想对方报告自己的MAC地址，否则丢弃这个包

- 若两台主机不在同一个子网，那么只能把数据包送到两个子网络连接处的网关去处理

传输层：建立端口到端口的连接（数据包供哪个程序使用）

- UDP
- TCP

应用层：规定应用程序的数据格式（如HTTP和HTTPS协议）

http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html

## 从浏览器输入URL到渲染界面成功的过程中发生了什么

https://mp.weixin.qq.com/s/z8aJZ14NAc-qXx3Qt4gZLQ

## CDN

尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载情况以及到用户的距离和响应时间等综合信息将用户的请求重新导向到离用户最近的服务节点上

https://www.zhihu.com/question/36514327?rf=37353035

## 跨域（从这往下没好好看）

https://segmentfault.com/a/1190000011145364

http://www.ruanyifeng.com/blog/2016/04/cors.html

## XSS、CSRF攻击

https://segmentfault.com/a/1190000007059639